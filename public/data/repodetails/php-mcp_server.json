{
  "mcp_name": "php-mcp/server",
  "mcp_description": "A PHP library facilitating the creation of MCP-compliant servers, enabling seamless integration of PHP applications with AI tools and external systems.",
  "mcp_id": "php-mcp_server",
  "fetch_timestamp": "2025-06-23T07:29:46.746137Z",
  "github_url": "https://github.com/php-mcp/server",
  "repository": {
    "name": "server",
    "full_name": "php-mcp/server",
    "description": "Core PHP implementation for the Model Context Protocol (MCP) server",
    "html_url": "https://github.com/php-mcp/server",
    "created_at": "2025-04-28T12:13:42Z",
    "updated_at": "2025-06-23T06:49:17Z",
    "pushed_at": "2025-06-21T19:14:53Z",
    "size": 602,
    "stargazers_count": 354,
    "watchers_count": 354,
    "forks_count": 20,
    "open_issues_count": 3,
    "language": "PHP",
    "license": "MIT License",
    "topics": [],
    "default_branch": "main",
    "owner": {
      "login": "php-mcp",
      "type": "Organization",
      "avatar_url": "https://avatars.githubusercontent.com/u/209475819?v=4",
      "html_url": "https://github.com/php-mcp"
    },
    "has_issues": true,
    "has_projects": true,
    "has_downloads": true,
    "has_wiki": true,
    "has_pages": false,
    "archived": false,
    "disabled": false,
    "visibility": "public",
    "network_count": 20,
    "subscribers_count": 7,
    "languages": {
      "PHP": 695577
    },
    "language_percentages": {
      "PHP": 100
    },
    "pull_requests_count": 15,
    "contributors_count": 3,
    "latest_release": {
      "tag_name": "3.0.0",
      "name": "v3.0.0",
      "published_at": "2025-06-21T19:12:06Z",
      "body": "This release brings support for the latest MCP protocol version along with enhanced schema generation, new transport capabilities, and streamlined APIs.\r\n\r\n## ✨ New Features\r\n\r\n* **StreamableHttpServerTransport**: New transport with resumability, event sourcing, and JSON response mode for production deployments\r\n* **Smart Schema Generation**: Automatic JSON schema generation from method signatures with optional `#[Schema]` attribute enhancements\r\n* **Completion Providers**: `#[CompletionProvider]` attribute for auto-completion in resource templates and prompts\r\n* **Batch Request Processing**: Full support for JSON-RPC 2.0 batch requests\r\n* **Enhanced Session Management**: Multiple session backends (array, cache, custom) with persistence and garbage collection\r\n\r\n## 🔥 Breaking Changes\r\n\r\n* **Schema Package Integration**: Now uses `php-mcp/schema` package for all DTOs, requests, responses, and content types\r\n* **Session Management**: `ClientStateManager` replaced with `SessionManager` and `Session` classes\r\n* **Component Reorganization**: `Support\\*` classes moved to `Utils\\*` namespace\r\n* **Request Processing**: `RequestHandler` renamed to `Dispatcher`\r\n\r\n*Note: Most of these changes are internal and won't affect your existing MCP element definitions and handlers.*\r\n\r\n## 🔧 Enhanced Features\r\n\r\n* **Improved Schema System**: The `#[Schema]` attribute can now be used at both method-level and parameter-level (previously parameter-level only)\r\n* **Better Error Handling**: Enhanced JSON-RPC error responses with proper status codes\r\n* **PSR-20 Clock Interface**: Time management with `SystemClock` implementation\r\n* **Event Store Interface**: Pluggable event storage for resumable connections\r\n\r\n## 📦 Dependencies\r\n\r\n* Now requires `php-mcp/schema` ^1.0\r\n* Enhanced PSR compliance (PSR-3, PSR-11, PSR-16, PSR-20)\r\n\r\n## 🚧 Migration Guide\r\n\r\n### Capabilities Configuration\r\n**Before:**\r\n```php\r\n->withCapabilities(Capabilities::forServer(\r\n    resourcesEnabled: true,\r\n    promptsEnabled: true,\r\n    toolsEnabled: true,\r\n    resourceSubscribe: true\r\n))\r\n```\r\n\r\n**After:**\r\n```php\r\n->withCapabilities(ServerCapabilities::make(\r\n    resources: true,\r\n    prompts: true,\r\n    tools: true,\r\n    resourcesSubscribe: true\r\n))\r\n```\r\n\r\n### Transport Upgrade (Optional)\r\nFor production HTTP deployments, consider upgrading to the new `StreamableHttpServerTransport`:\r\n\r\n**Before:**\r\n```php\r\n$transport = new HttpServerTransport(host: '127.0.0.1', port: 8080);\r\n```\r\n\r\n**After:**\r\n```php\r\n$transport = new StreamableHttpServerTransport(host: '127.0.0.1',  port: 8080);\r\n```\r\n\r\n## 📚 Documentation\r\n\r\n* Complete README rewrite with comprehensive examples and deployment guides\r\n* New production deployment section covering VPS, Docker, and SSL setup\r\n* Enhanced schema generation documentation\r\n* Migration guide for v2.x users\r\n\r\n**Full Changelog**: https://github.com/php-mcp/server/compare/2.3.1...3.0.0",
      "prerelease": false,
      "draft": false
    },
    "tags": [
      {
        "name": "3.0.0",
        "commit_sha": "c627581ae94bea17b8d2b773e1c3d7b1eee49ccc"
      },
      {
        "name": "2.3.1",
        "commit_sha": "686cac47af096907179ebf9ab38c9d5a75c5aa6f"
      },
      {
        "name": "2.3.0",
        "commit_sha": "4103ef9fc3bb9e0a4b33a9ad769489daea001bac"
      },
      {
        "name": "2.2.1",
        "commit_sha": "b3f97f7e3408082ee5f10a8d35674199b691d380"
      },
      {
        "name": "2.2.0",
        "commit_sha": "9892dd32793a6dff324c5024d812645d10cdf786"
      },
      {
        "name": "2.1.0",
        "commit_sha": "c8840af72dce68838f82324c175e4af76a57825b"
      },
      {
        "name": "2.0.1",
        "commit_sha": "2047d239511feccb6a17d20b50a4a82caedcc0b2"
      },
      {
        "name": "2.0.0",
        "commit_sha": "0e031f7ece68d4ddc8ff92691332858d24efd1df"
      },
      {
        "name": "1.1.0",
        "commit_sha": "2ff0f7dde2178741fbcf7a64c767f5f3e272b392"
      },
      {
        "name": "1.0.0",
        "commit_sha": "83fa383dedfa769cc20cc2777cea2e6412d64a29"
      }
    ],
    "latest_version": "3.0.0"
  },
  "readme": "# PHP MCP Server\n\n[![Latest Version on Packagist](https://img.shields.io/packagist/v/php-mcp/server.svg?style=flat-square)](https://packagist.org/packages/php-mcp/server)\n[![Total Downloads](https://img.shields.io/packagist/dt/php-mcp/server.svg?style=flat-square)](https://packagist.org/packages/php-mcp/server)\n[![Tests](https://img.shields.io/github/actions/workflow/status/php-mcp/server/tests.yml?branch=main&style=flat-square)](https://github.com/php-mcp/server/actions/workflows/tests.yml)\n[![License](https://img.shields.io/packagist/l/php-mcp/server.svg?style=flat-square)](LICENSE)\n\n**A comprehensive and production-ready PHP implementation of the [Model Context Protocol (MCP)](https://modelcontextprotocol.io/introduction) server. Built for PHP 8.1+ with modern architecture, extensive testing, and flexible transport options.**\n\nThe PHP MCP Server enables you to expose your PHP application's functionality as standardized MCP **Tools**, **Resources**, and **Prompts**, allowing AI assistants (like Anthropic's Claude, Cursor IDE, OpenAI's ChatGPT, etc.) to interact with your backend using the MCP standard.\n\n## 🚀 Key Features\n\n- **🏗️ Modern Architecture**: Built with PHP 8.1+ features, PSR standards, and modular design\n- **📡 Multiple Transports**: Supports `stdio`, `http+sse`, and new **streamable HTTP** with resumability\n- **🎯 Attribute-Based Definition**: Use PHP 8 Attributes (`#[McpTool]`, `#[McpResource]`, etc.) for zero-config element registration\n- **📝 Smart Schema Generation**: Automatic JSON schema generation from method signatures with optional `#[Schema]` attribute enhancements\n- **⚡ Session Management**: Advanced session handling with multiple storage backends\n- **🔄 Event-Driven**: ReactPHP-based for high concurrency and non-blocking operations  \n- **📊 Batch Processing**: Full support for JSON-RPC batch requests\n- **💾 Smart Caching**: Intelligent caching of discovered elements with manual override precedence\n- **🧪 Completion Providers**: Built-in support for argument completion in tools and prompts\n- **🔌 Dependency Injection**: Full PSR-11 container support with auto-wiring\n- **📋 Comprehensive Testing**: Extensive test suite with integration tests for all transports\n\nThis package supports the **2025-03-26** version of the Model Context Protocol with backward compatibility.\n\n## 📋 Requirements\n\n- **PHP** >= 8.1\n- **Composer**\n- **For HTTP Transport**: An event-driven PHP environment (CLI recommended)\n- **Extensions**: `json`, `mbstring`, `pcre` (typically enabled by default)\n\n## 📦 Installation\n\n```bash\ncomposer require php-mcp/server\n```\n\n> **💡 Laravel Users**: Consider using [`php-mcp/laravel`](https://github.com/php-mcp/laravel) for enhanced framework integration, configuration management, and Artisan commands.\n\n## ⚡ Quick Start: Stdio Server with Discovery\n\nThis example demonstrates the most common usage pattern - a `stdio` server using attribute discovery.\n\n**1. Define Your MCP Elements**\n\nCreate `src/CalculatorElements.php`:\n\n```php\n<?php\n\nnamespace App;\n\nuse PhpMcp\\Server\\Attributes\\McpTool;\nuse PhpMcp\\Server\\Attributes\\Schema;\n\nclass CalculatorElements\n{\n    /**\n     * Adds two numbers together.\n     * \n     * @param int $a The first number\n     * @param int $b The second number  \n     * @return int The sum of the two numbers\n     */\n    #[McpTool(name: 'add_numbers')]\n    public function add(int $a, int $b): int\n    {\n        return $a + $b;\n    }\n\n    /**\n     * Calculates power with validation.\n     */\n    #[McpTool(name: 'calculate_power')]\n    public function power(\n        #[Schema(type: 'number', minimum: 0, maximum: 1000)]\n        float $base,\n        \n        #[Schema(type: 'integer', minimum: 0, maximum: 10)]\n        int $exponent\n    ): float {\n        return pow($base, $exponent);\n    }\n}\n```\n\n**2. Create the Server Script**\n\nCreate `mcp-server.php`:\n\n```php\n#!/usr/bin/env php\n<?php\n\ndeclare(strict_types=1);\n\nrequire_once __DIR__ . '/vendor/autoload.php';\n\nuse PhpMcp\\Server\\Server;\nuse PhpMcp\\Server\\Transports\\StdioServerTransport;\n\ntry {\n    // Build server configuration\n    $server = Server::make()\n        ->withServerInfo('PHP Calculator Server', '1.0.0') \n        ->build();\n\n    // Discover MCP elements via attributes\n    $server->discover(\n        basePath: __DIR__,\n        scanDirs: ['src']\n    );\n\n    // Start listening via stdio transport\n    $transport = new StdioServerTransport();\n    $server->listen($transport);\n\n} catch (\\Throwable $e) {\n    fwrite(STDERR, \"[CRITICAL ERROR] \" . $e->getMessage() . \"\\n\");\n    exit(1);\n}\n```\n\n**3. Configure Your MCP Client**\n\nAdd to your client configuration (e.g., `.cursor/mcp.json`):\n\n```json\n{\n    \"mcpServers\": {\n        \"php-calculator\": {\n            \"command\": \"php\",\n            \"args\": [\"/absolute/path/to/your/mcp-server.php\"]\n        }\n    }\n}\n```\n\n**4. Test the Server**\n\nYour AI assistant can now call:\n- `add_numbers` - Add two integers\n- `calculate_power` - Calculate power with validation constraints\n\n## 🏗️ Architecture Overview\n\nThe PHP MCP Server uses a modern, decoupled architecture:\n\n```\n┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐\n│   MCP Client    │◄──►│   Transport      │◄──►│   Protocol      │\n│  (Claude, etc.) │    │ (Stdio/HTTP/SSE) │    │   (JSON-RPC)    │\n└─────────────────┘    └──────────────────┘    └─────────────────┘\n                                                         │\n                       ┌─────────────────┐              │\n                       │ Session Manager │◄─────────────┤\n                       │ (Multi-backend) │              │\n                       └─────────────────┘              │\n                                                         │\n┌─────────────────┐    ┌──────────────────┐              │\n│   Dispatcher    │◄───│   Server Core    │◄─────────────┤\n│ (Method Router) │    │   Configuration  │              │\n└─────────────────┘    └──────────────────┘              │\n         │                                               │\n         ▼                                               │\n┌─────────────────┐    ┌──────────────────┐              │\n│    Registry     │    │   Elements       │◄─────────────┘\n│  (Element Store)│◄──►│ (Tools/Resources │\n└─────────────────┘    │  Prompts/etc.)   │\n                       └──────────────────┘\n```\n\n### Core Components\n\n- **`ServerBuilder`**: Fluent configuration interface (`Server::make()->...->build()`)\n- **`Server`**: Central coordinator containing all configured components\n- **`Protocol`**: JSON-RPC 2.0 handler bridging transports and core logic\n- **`SessionManager`**: Multi-backend session storage (array, cache, custom)\n- **`Dispatcher`**: Method routing and request processing\n- **`Registry`**: Element storage with smart caching and precedence rules\n- **`Elements`**: Registered MCP components (Tools, Resources, Prompts, Templates)\n\n### Transport Options\n\n1. **`StdioServerTransport`**: Standard I/O for direct client launches\n2. **`HttpServerTransport`**: HTTP + Server-Sent Events for web integration  \n3. **`StreamableHttpServerTransport`**: Enhanced HTTP with resumability and event sourcing\n\n## ⚙️ Server Configuration\n\n### Basic Configuration\n\n```php\nuse PhpMcp\\Server\\Server;\nuse PhpMcp\\Schema\\ServerCapabilities;\n\n$server = Server::make()\n    ->withServerInfo('My App Server', '2.1.0')\n    ->withCapabilities(ServerCapabilities::make(\n        resources: true,\n        resourcesSubscribe: true,\n        prompts: true,\n        tools: true\n    ))\n    ->withPaginationLimit(100)\n    ->build();\n```\n\n### Advanced Configuration with Dependencies\n\n```php\nuse Psr\\Log\\Logger;\nuse Psr\\SimpleCache\\CacheInterface;\nuse Psr\\Container\\ContainerInterface;\n\n$server = Server::make()\n    ->withServerInfo('Production Server', '1.0.0')\n    ->withLogger($myPsrLogger)                    // PSR-3 Logger\n    ->withCache($myPsrCache)                      // PSR-16 Cache  \n    ->withContainer($myPsrContainer)              // PSR-11 Container\n    ->withSession('cache', 7200)                  // Cache-backed sessions, 2hr TTL\n    ->withPaginationLimit(50)                     // Limit list responses\n    ->build();\n```\n\n### Session Management Options\n\n```php\n// In-memory sessions (default, not persistent)\n->withSession('array', 3600)\n\n// Cache-backed sessions (persistent across restarts)  \n->withSession('cache', 7200)\n\n// Custom session handler (implement SessionHandlerInterface)\n->withSessionHandler(new MyCustomSessionHandler(), 1800)\n```\n\n## 🎯 Defining MCP Elements\n\nThe server provides two powerful ways to define MCP elements: **Attribute-Based Discovery** (recommended) and **Manual Registration**. Both can be combined, with manual registrations taking precedence.\n\n### Element Types\n\n- **🔧 Tools**: Executable functions/actions (e.g., `calculate`, `send_email`, `query_database`)\n- **📄 Resources**: Static content/data (e.g., `config://settings`, `file://readme.txt`)\n- **📋 Resource Templates**: Dynamic resources with URI patterns (e.g., `user://{id}/profile`)  \n- **💬 Prompts**: Conversation starters/templates (e.g., `summarize`, `translate`)\n\n### 1. 🏷️ Attribute-Based Discovery (Recommended)\n\nUse PHP 8 attributes to mark methods or invokable classes as MCP elements. The server will discover them via filesystem scanning.\n\n```php\nuse PhpMcp\\Server\\Attributes\\{McpTool, McpResource, McpResourceTemplate, McpPrompt};\n\nclass UserManager\n{\n    /**\n     * Creates a new user account.\n     */\n    #[McpTool(name: 'create_user')]\n    public function createUser(string $email, string $password, string $role = 'user'): array\n    {\n        // Create user logic\n        return ['id' => 123, 'email' => $email, 'role' => $role];\n    }\n\n    /**\n     * Get user configuration.\n     */\n    #[McpResource(\n        uri: 'config://user/settings',\n        mimeType: 'application/json'\n    )]\n    public function getUserConfig(): array\n    {\n        return ['theme' => 'dark', 'notifications' => true];\n    }\n\n    /**\n     * Get user profile by ID.\n     */\n    #[McpResourceTemplate(\n        uriTemplate: 'user://{userId}/profile',\n        mimeType: 'application/json'\n    )]\n    public function getUserProfile(string $userId): array\n    {\n        return ['id' => $userId, 'name' => 'John Doe'];\n    }\n\n    /**\n     * Generate welcome message prompt.\n     */\n    #[McpPrompt(name: 'welcome_user')]\n    public function welcomeUserPrompt(string $username, string $role): array\n    {\n        return [\n            ['role' => 'user', 'content' => \"Create a welcome message for {$username} with role {$role}\"]\n        ];\n    }\n}\n```\n\n**Discovery Process:**\n\n```php\n// Build server first\n$server = Server::make()\n    ->withServerInfo('My App Server', '1.0.0')\n    ->build();\n\n// Then discover elements\n$server->discover(\n    basePath: __DIR__,\n    scanDirs: ['src/Handlers', 'src/Services'],  // Directories to scan\n    excludeDirs: ['src/Tests'],                  // Directories to skip\n    saveToCache: true                            // Cache results (default: true)\n);\n```\n\n**Available Attributes:**\n\n- **`#[McpTool]`**: Executable actions\n- **`#[McpResource]`**: Static content accessible via URI\n- **`#[McpResourceTemplate]`**: Dynamic resources with URI templates  \n- **`#[McpPrompt]`**: Conversation templates and prompt generators\n\n### 2. 🔧 Manual Registration \n\nRegister elements programmatically using the `ServerBuilder` before calling `build()`. Useful for dynamic registration or when you prefer explicit control.\n\n```php\nuse App\\Handlers\\{EmailHandler, ConfigHandler, UserHandler, PromptHandler};\nuse PhpMcp\\Schema\\{ToolAnnotations, Annotations};\n\n$server = Server::make()\n    ->withServerInfo('Manual Registration Server', '1.0.0')\n    \n    // Register a tool with handler method\n    ->withTool(\n        [EmailHandler::class, 'sendEmail'],     // Handler: [class, method]\n        name: 'send_email',                     // Tool name (optional)\n        description: 'Send email to user',     // Description (optional)\n        annotations: ToolAnnotations::make(     // Annotations (optional)\n            title: 'Send Email Tool'\n        )\n    )\n    \n    // Register invokable class as tool\n    ->withTool(UserHandler::class)             // Handler: Invokable class\n    \n    // Register a resource\n    ->withResource(\n        [ConfigHandler::class, 'getConfig'],\n        uri: 'config://app/settings',          // URI (required)\n        mimeType: 'application/json'           // MIME type (optional)\n    )\n    \n    // Register a resource template\n    ->withResourceTemplate(\n        [UserHandler::class, 'getUserProfile'],\n        uriTemplate: 'user://{userId}/profile'  // URI template (required)\n    )\n    \n    // Register a prompt\n    ->withPrompt(\n        [PromptHandler::class, 'generateSummary'],\n        name: 'summarize_text'                  // Prompt name (optional)\n    )\n    \n    ->build();\n```\n\n**Key Features:**\n\n- **Handler Formats**: Use `[ClassName::class, 'methodName']` or `InvokableClass::class`\n- **Dependency Injection**: Handlers resolved via configured PSR-11 container\n- **Immediate Registration**: Elements registered when `build()` is called\n- **No Caching**: Manual elements are never cached (always fresh)\n- **Precedence**: Manual registrations override discovered elements with same identifier\n\n### 🏆 Element Precedence & Discovery\n\n**Precedence Rules:**\n- Manual registrations **always** override discovered/cached elements with the same identifier\n- Discovered elements are cached for performance (configurable)\n- Cache is automatically invalidated on fresh discovery runs\n\n**Discovery Process:**\n\n```php\n$server->discover(\n    basePath: __DIR__,\n    scanDirs: ['src/Handlers', 'src/Services'],  // Scan these directories\n    excludeDirs: ['tests', 'vendor'],            // Skip these directories\n    force: false,                                // Force re-scan (default: false)\n    saveToCache: true                            // Save to cache (default: true)\n);\n```\n\n**Caching Behavior:**\n- Only **discovered** elements are cached (never manual registrations)\n- Cache loaded automatically during `build()` if available\n- Fresh `discover()` calls clear and rebuild cache\n- Use `force: true` to bypass discovery-already-ran check\n\n## 🚀 Running the Server (Transports)\n\nThe server core is transport-agnostic. Choose a transport based on your deployment needs:\n\n### 1. 📟 Stdio Transport\n\n**Best for**: Direct client execution, command-line tools, simple deployments\n\n```php\nuse PhpMcp\\Server\\Transports\\StdioServerTransport;\n\n$server = Server::make()\n    ->withServerInfo('Stdio Server', '1.0.0')\n    ->build();\n\n$server->discover(__DIR__, ['src']);\n\n// Create stdio transport (uses STDIN/STDOUT by default)\n$transport = new StdioServerTransport();\n\n// Start listening (blocking call)\n$server->listen($transport);\n```\n\n**Client Configuration:**\n```json\n{\n    \"mcpServers\": {\n        \"my-php-server\": {\n            \"command\": \"php\",\n            \"args\": [\"/absolute/path/to/server.php\"]\n        }\n    }\n}\n```\n\n> ⚠️ **Important**: When using stdio transport, **never** write to `STDOUT` in your handlers (use `STDERR` for debugging). `STDOUT` is reserved for JSON-RPC communication.\n\n### 2. 🌐 HTTP + Server-Sent Events Transport (Deprecated)\n\n> ⚠️ **Note**: This transport is deprecated in the latest MCP protocol version but remains available for backwards compatibility. For new projects, use the [StreamableHttpServerTransport](#3--streamable-http-transport-new) which provides enhanced features and better protocol compliance.\n\n**Best for**: Legacy applications requiring backwards compatibility\n\n```php\nuse PhpMcp\\Server\\Transports\\HttpServerTransport;\n\n$server = Server::make()\n    ->withServerInfo('HTTP Server', '1.0.0')\n    ->withLogger($logger)  // Recommended for HTTP\n    ->build();\n\n$server->discover(__DIR__, ['src']);\n\n// Create HTTP transport\n$transport = new HttpServerTransport(\n    host: '127.0.0.1',      // MCP protocol prohibits 0.0.0.0\n    port: 8080,             // Port number\n    mcpPathPrefix: 'mcp'    // URL prefix (/mcp/sse, /mcp/message)\n);\n\n$server->listen($transport);\n```\n\n**Client Configuration:**\n```json\n{\n    \"mcpServers\": {\n        \"my-http-server\": {\n            \"url\": \"http://localhost:8080/mcp/sse\"\n        }\n    }\n}\n```\n\n**Endpoints:**\n- **SSE Connection**: `GET /mcp/sse`\n- **Message Sending**: `POST /mcp/message?clientId={clientId}`\n\n### 3. 🔄 Streamable HTTP Transport (Recommended)\n\n**Best for**: Production deployments, remote MCP servers, multiple clients, resumable connections\n\n```php\nuse PhpMcp\\Server\\Transports\\StreamableHttpServerTransport;\n\n$server = Server::make()\n    ->withServerInfo('Streamable Server', '1.0.0')\n    ->withLogger($logger)\n    ->withCache($cache)     // Required for resumability\n    ->build();\n\n$server->discover(__DIR__, ['src']);\n\n// Create streamable transport with resumability\n$transport = new StreamableHttpServerTransport(\n    host: '127.0.0.1',      // MCP protocol prohibits 0.0.0.0\n    port: 8080,\n    mcpPathPrefix: 'mcp',\n    enableJsonResponse: false  // Use SSE streaming (default)\n);\n\n$server->listen($transport);\n```\n\n**JSON Response Mode:**\n\nThe `enableJsonResponse` option controls how responses are delivered:\n\n- **`false` (default)**: Uses Server-Sent Events (SSE) streams for responses. Best for tools that may take time to process.\n- **`true`**: Returns immediate JSON responses without opening SSE streams. Use this when your tools execute quickly and don't need streaming.\n\n```php\n// For fast-executing tools, enable JSON mode\n$transport = new StreamableHttpServerTransport(\n    host: '127.0.0.1',\n    port: 8080,\n    enableJsonResponse: true  // Immediate JSON responses\n);\n```\n\n**Features:**\n- **Resumable connections** - clients can reconnect and replay missed events\n- **Event sourcing** - all events are stored for replay\n- **JSON mode** - optional JSON-only responses for fast tools\n- **Enhanced session management** - persistent session state\n- **Multiple client support** - designed for concurrent clients\n\n## 📋 Schema Generation and Validation\n\nThe server automatically generates JSON schemas for tool parameters using a sophisticated priority system that combines PHP type hints, docblock information, and the optional `#[Schema]` attribute. These generated schemas are used both for input validation and for providing schema information to MCP clients.\n\n### Schema Generation Priority\n\nThe server follows this order of precedence when generating schemas:\n\n1. **`#[Schema]` attribute with `definition`** - Complete schema override (highest precedence)\n2. **Parameter-level `#[Schema]` attribute** - Parameter-specific schema enhancements\n3. **Method-level `#[Schema]` attribute** - Method-wide schema configuration\n4. **PHP type hints + docblocks** - Automatic inference from code (lowest precedence)\n\nWhen a `definition` is provided in the Schema attribute, all automatic inference is bypassed and the complete definition is used as-is.\n\n### Parameter-Level Schema Attributes\n\n```php\nuse PhpMcp\\Server\\Attributes\\{McpTool, Schema};\n\n#[McpTool(name: 'validate_user')]\npublic function validateUser(\n    #[Schema(format: 'email')]              // PHP already knows it's string\n    string $email,\n    \n    #[Schema(\n        pattern: '^[A-Z][a-z]+$',\n        description: 'Capitalized name'\n    )]\n    string $name,\n    \n    #[Schema(minimum: 18, maximum: 120)]    // PHP already knows it's integer\n    int $age\n): bool {\n    return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;\n}\n```\n\n### Method-Level Schema\n\n```php\n/**\n * Process user data with nested validation.\n */\n#[McpTool(name: 'create_user')]\n#[Schema(\n    properties: [\n        'profile' => [\n            'type' => 'object',\n            'properties' => [\n                'name' => ['type' => 'string', 'minLength' => 2],\n                'age' => ['type' => 'integer', 'minimum' => 18],\n                'email' => ['type' => 'string', 'format' => 'email']\n            ],\n            'required' => ['name', 'email']\n        ]\n    ],\n    required: ['profile']\n)]\npublic function createUser(array $userData): array\n{\n    // PHP type hint provides base 'array' type\n    // Method-level Schema adds object structure validation\n    return ['id' => 123, 'status' => 'created'];\n}\n```\n\n### Complete Schema Override (Method-Level Only)\n\n```php\n#[McpTool(name: 'process_api_request')]\n#[Schema(definition: [\n    'type' => 'object',\n    'properties' => [\n        'endpoint' => ['type' => 'string', 'format' => 'uri'],\n        'method' => ['type' => 'string', 'enum' => ['GET', 'POST', 'PUT', 'DELETE']],\n        'headers' => [\n            'type' => 'object',\n            'patternProperties' => [\n                '^[A-Za-z0-9-]+$' => ['type' => 'string']\n            ]\n        ]\n    ],\n    'required' => ['endpoint', 'method']\n])]\npublic function processApiRequest(string $endpoint, string $method, array $headers): array\n{\n    // PHP type hints are completely ignored when definition is provided\n    // The schema definition above takes full precedence\n    return ['status' => 'processed', 'endpoint' => $endpoint];\n}\n```\n\n> ⚠️ **Important**: Complete schema definition override should rarely be used. It bypasses all automatic schema inference and requires you to define the entire JSON schema manually. Only use this if you're well-versed with JSON Schema specification and have complex validation requirements that cannot be achieved through the priority system. In most cases, parameter-level and method-level `#[Schema]` attributes provide sufficient flexibility.\n\n## 🎨 Return Value Formatting\n\nThe server automatically formats return values from your handlers into appropriate MCP content types:\n\n### Automatic Formatting\n\n```php\n// Simple values are auto-wrapped in TextContent\npublic function getString(): string { return \"Hello World\"; }           // → TextContent\npublic function getNumber(): int { return 42; }                        // → TextContent  \npublic function getBool(): bool { return true; }                       // → TextContent\npublic function getArray(): array { return ['key' => 'value']; }       // → TextContent (JSON)\n\n// Null handling\npublic function getNull(): ?string { return null; }                    // → TextContent(\"(null)\")\npublic function returnVoid(): void { /* no return */ }                 // → Empty content\n```\n\n### Advanced Content Types\n\n```php\nuse PhpMcp\\Schema\\Content\\{TextContent, ImageContent, AudioContent, ResourceContent};\n\npublic function getFormattedCode(): TextContent\n{\n    return TextContent::code('<?php echo \"Hello\";', 'php');\n}\n\npublic function getMarkdown(): TextContent  \n{\n    return TextContent::make('# Title\\n\\nContent here');\n}\n\npublic function getImage(): ImageContent\n{\n    return ImageContent::make(\n        data: base64_encode(file_get_contents('image.png')),\n        mimeType: 'image/png'\n    );\n}\n\npublic function getAudio(): AudioContent\n{\n    return AudioContent::make(\n        data: base64_encode(file_get_contents('audio.mp3')),\n        mimeType: 'audio/mpeg'\n    );\n}\n```\n\n### File and Stream Handling\n\n```php\n// File objects are automatically read and formatted\npublic function getFileContent(): \\SplFileInfo\n{\n    return new \\SplFileInfo('/path/to/file.txt');  // Auto-detects MIME type\n}\n\n// Stream resources are read completely\npublic function getStreamContent()\n{\n    $stream = fopen('/path/to/data.json', 'r');\n    return $stream;  // Will be read and closed automatically\n}\n\n// Structured resource responses\npublic function getStructuredResource(): array\n{\n    return [\n        'text' => 'File content here',\n        'mimeType' => 'text/plain'\n    ];\n    \n    // Or for binary data:\n    // return [\n    //     'blob' => base64_encode($binaryData),\n    //     'mimeType' => 'application/octet-stream'\n    // ];\n}\n```\n\n## 🔄 Batch Processing\n\nThe server automatically handles JSON-RPC batch requests:\n\n```php\n// Client can send multiple requests in a single HTTP call:\n[\n    {\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"tools/call\", \"params\": {...}},\n    {\"jsonrpc\": \"2.0\", \"method\": \"notifications/ping\"},              // notification\n    {\"jsonrpc\": \"2.0\", \"id\": \"2\", \"method\": \"tools/call\", \"params\": {...}}\n]\n\n// Server returns batch response (excluding notifications):\n[\n    {\"jsonrpc\": \"2.0\", \"id\": \"1\", \"result\": {...}},\n    {\"jsonrpc\": \"2.0\", \"id\": \"2\", \"result\": {...}}\n]\n```\n\n## 🔧 Advanced Features\n\n### Completion Providers\n\nCompletion providers enable MCP clients to offer auto-completion suggestions in their user interfaces. They are specifically designed for **Resource Templates** and **Prompts** to help users discover available options for dynamic parts like template variables or prompt arguments.\n\n> **Note**: Tools and resources can be discovered via standard MCP commands (`tools/list`, `resources/list`), so completion providers are not needed for them. Completion providers are used only for resource templates (URI variables) and prompt arguments.\n\nCompletion providers must implement the `CompletionProviderInterface`:\n\n```php\nuse PhpMcp\\Server\\Contracts\\CompletionProviderInterface;\nuse PhpMcp\\Server\\Contracts\\SessionInterface;\nuse PhpMcp\\Server\\Attributes\\{McpResourceTemplate, CompletionProvider};\n\nclass UserIdCompletionProvider implements CompletionProviderInterface\n{\n    public function getCompletions(string $currentValue, SessionInterface $session): array\n    {\n        // Return completion suggestions based on current input\n        $allUsers = ['user_1', 'user_2', 'user_3', 'admin_user'];\n        \n        // Filter based on what user has typed so far\n        return array_filter($allUsers, fn($user) => str_starts_with($user, $currentValue));\n    }\n}\n\nclass UserService\n{\n    #[McpResourceTemplate(uriTemplate: 'user://{userId}/profile')]\n    public function getUserProfile(\n        #[CompletionProvider(UserIdCompletionProvider::class)]\n        string $userId\n    ): array {\n        // Always validate input even with completion providers\n        // Users can still pass any value regardless of completion suggestions\n        if (!$this->isValidUserId($userId)) {\n            throw new \\InvalidArgumentException('Invalid user ID provided');\n        }\n        \n        return ['id' => $userId, 'name' => 'John Doe'];\n    }\n}\n```\n\n> **Important**: Completion providers only offer suggestions to users in the MCP client interface. Users can still input any value, so always validate parameters in your handlers regardless of completion provider constraints.\n\n### Custom Dependency Injection\n\nYour MCP element handlers can use constructor dependency injection to access services like databases, APIs, or other business logic. When handlers have constructor dependencies, you must provide a pre-configured PSR-11 container that contains those dependencies.\n\nBy default, the server uses a `BasicContainer` - a simple implementation that attempts to auto-wire dependencies by instantiating classes with parameterless constructors. For dependencies that require configuration (like database connections), you can either manually add them to the BasicContainer or use a more advanced PSR-11 container like PHP-DI or Laravel's container.\n\n```php\nuse Psr\\Container\\ContainerInterface;\n\nclass DatabaseService\n{\n    public function __construct(private \\PDO $pdo) {}\n    \n    #[McpTool(name: 'query_users')]\n    public function queryUsers(): array\n    {\n        $stmt = $this->pdo->query('SELECT * FROM users');\n        return $stmt->fetchAll();\n    }\n}\n\n// Option 1: Use the basic container and manually add dependencies\n$basicContainer = new \\PhpMcp\\Server\\Defaults\\BasicContainer();\n$basicContainer->set(\\PDO::class, new \\PDO('sqlite::memory:'));\n\n// Option 2: Use any PSR-11 compatible container (PHP-DI, Laravel, etc.)\n$container = new \\DI\\Container();\n$container->set(\\PDO::class, new \\PDO('mysql:host=localhost;dbname=app', $user, $pass));\n\n$server = Server::make()\n    ->withContainer($basicContainer)  // Handlers get dependencies auto-injected\n    ->build();\n```\n\n### Resource Subscriptions\n\n```php\nuse PhpMcp\\Schema\\ServerCapabilities;\n\n$server = Server::make()\n    ->withCapabilities(ServerCapabilities::make(\n        resourcesSubscribe: true,  // Enable resource subscriptions\n        prompts: true,\n        tools: true\n    ))\n    ->build();\n\n// In your resource handler, you can notify clients of changes:\n#[McpResource(uri: 'file://config.json')]\npublic function getConfig(): array\n{\n    // When config changes, notify subscribers\n    $this->notifyResourceChange('file://config.json');\n    return ['setting' => 'value'];\n}\n```\n\n### Resumability and Event Store\n\nFor production deployments using `StreamableHttpServerTransport`, you can implement resumability with event sourcing by providing a custom event store:\n\n```php\nuse PhpMcp\\Server\\Contracts\\EventStoreInterface;\nuse PhpMcp\\Server\\Defaults\\InMemoryEventStore;\nuse PhpMcp\\Server\\Transports\\StreamableHttpServerTransport;\n\n// Use the built-in in-memory event store (for development/testing)\n$eventStore = new InMemoryEventStore();\n\n// Or implement your own persistent event store\nclass DatabaseEventStore implements EventStoreInterface\n{\n    public function storeEvent(string $streamId, string $message): string\n    {\n        // Store event in database and return unique event ID\n        return $this->database->insert('events', [\n            'stream_id' => $streamId,\n            'message' => $message,\n            'created_at' => now()\n        ]);\n    }\n\n    public function replayEventsAfter(string $lastEventId, callable $sendCallback): void\n    {\n        // Replay events for resumability\n        $events = $this->database->getEventsAfter($lastEventId);\n        foreach ($events as $event) {\n            $sendCallback($event['id'], $event['message']);\n        }\n    }\n}\n\n// Configure transport with event store\n$transport = new StreamableHttpServerTransport(\n    host: '127.0.0.1',\n    port: 8080,\n    eventStore: new DatabaseEventStore()  // Enable resumability\n);\n```\n\n### Custom Session Handlers\n\nImplement custom session storage by creating a class that implements `SessionHandlerInterface`:\n\n```php\nuse PhpMcp\\Server\\Contracts\\SessionHandlerInterface;\n\nclass DatabaseSessionHandler implements SessionHandlerInterface\n{\n    public function __construct(private \\PDO $db) {}\n\n    public function read(string $id): string|false\n    {\n        $stmt = $this->db->prepare('SELECT data FROM sessions WHERE id = ?');\n        $stmt->execute([$id]);\n        $session = $stmt->fetch(\\PDO::FETCH_ASSOC);\n        return $session ? $session['data'] : false;\n    }\n\n    public function write(string $id, string $data): bool\n    {\n        $stmt = $this->db->prepare(\n            'INSERT OR REPLACE INTO sessions (id, data, updated_at) VALUES (?, ?, ?)'\n        );\n        return $stmt->execute([$id, $data, time()]);\n    }\n\n    public function destroy(string $id): bool\n    {\n        $stmt = $this->db->prepare('DELETE FROM sessions WHERE id = ?');\n        return $stmt->execute([$id]);\n    }\n\n    public function gc(int $maxLifetime): array\n    {\n        $cutoff = time() - $maxLifetime;\n        $stmt = $this->db->prepare('DELETE FROM sessions WHERE updated_at < ?');\n        $stmt->execute([$cutoff]);\n        return []; // Return array of cleaned session IDs if needed\n    }\n}\n\n// Use custom session handler\n$server = Server::make()\n    ->withSessionHandler(new DatabaseSessionHandler(), 3600)\n    ->build();\n```\n\n### SSL Context Configuration\n\nFor HTTPS deployments of `StreamableHttpServerTransport`, configure SSL context options:\n\n```php\n$sslContext = [\n    'ssl' => [\n        'local_cert' => '/path/to/certificate.pem',\n        'local_pk' => '/path/to/private-key.pem',\n        'verify_peer' => false,\n        'allow_self_signed' => true,\n    ]\n];\n\n$transport = new StreamableHttpServerTransport(\n    host: '0.0.0.0',\n    port: 8443,\n    sslContext: $sslContext\n);\n```\n\n> **SSL Context Reference**: For complete SSL context options, see the [PHP SSL Context Options documentation](https://www.php.net/manual/en/context.ssl.php).\n## 🔍 Error Handling & Debugging\n\nThe server provides comprehensive error handling and debugging capabilities:\n\n### Exception Handling\n\nTool handlers can throw any PHP exception when errors occur. The server automatically converts these exceptions into proper JSON-RPC error responses for MCP clients.\n\n```php\n#[McpTool(name: 'divide_numbers')]\npublic function divideNumbers(float $dividend, float $divisor): float\n{\n    if ($divisor === 0.0) {\n        // Any exception with descriptive message will be sent to client\n        throw new \\InvalidArgumentException('Division by zero is not allowed');\n    }\n    \n    return $dividend / $divisor;\n}\n\n#[McpTool(name: 'calculate_factorial')]\npublic function calculateFactorial(int $number): int\n{\n    if ($number < 0) {\n        throw new \\InvalidArgumentException('Factorial is not defined for negative numbers');\n    }\n    \n    if ($number > 20) {\n        throw new \\OverflowException('Number too large, factorial would cause overflow');\n    }\n    \n    // Implementation continues...\n    return $this->factorial($number);\n}\n```\n\nThe server will convert these exceptions into appropriate JSON-RPC error responses that MCP clients can understand and display to users.\n\n### Logging and Debugging\n\n```php\nuse Psr\\Log\\LoggerInterface;\n\nclass DebugAwareHandler\n{\n    public function __construct(private LoggerInterface $logger) {}\n    \n    #[McpTool(name: 'debug_tool')]\n    public function debugTool(string $data): array\n    {\n        $this->logger->info('Processing debug tool', ['input' => $data]);\n        \n        // For stdio transport, use STDERR for debug output\n        fwrite(STDERR, \"Debug: Processing data length: \" . strlen($data) . \"\\n\");\n        \n        return ['processed' => true];\n    }\n}\n```\n\n## 🚀 Production Deployment\n\nSince `$server->listen()` runs a persistent process, you can deploy it using any strategy that suits your infrastructure needs. The server can be deployed on VPS, cloud instances, containers, or any environment that supports long-running processes.\n\nHere are two popular deployment approaches to consider:\n\n### Option 1: VPS with Supervisor + Nginx (Recommended)\n\n**Best for**: Most production deployments, cost-effective, full control\n\n```bash\n# 1. Install your application on VPS\ngit clone https://github.com/yourorg/your-mcp-server.git /var/www/mcp-server\ncd /var/www/mcp-server\ncomposer install --no-dev --optimize-autoloader\n\n# 2. Install Supervisor\nsudo apt-get install supervisor\n\n# 3. Create Supervisor configuration\nsudo nano /etc/supervisor/conf.d/mcp-server.conf\n```\n\n**Supervisor Configuration:**\n```ini\n[program:mcp-server]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=php /var/www/mcp-server/server.php --transport=http --host=127.0.0.1 --port=8080\nautostart=true\nautorestart=true\nstopasgroup=true\nkillasgroup=true\nuser=www-data\nnumprocs=1\nredirect_stderr=true\nstdout_logfile=/var/log/mcp-server.log\nstdout_logfile_maxbytes=10MB\nstdout_logfile_backups=3\n```\n\n**Nginx Configuration with SSL:**\n```nginx\n# /etc/nginx/sites-available/mcp-server\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n    server_name mcp.yourdomain.com;\n\n    # SSL configuration\n    ssl_certificate /etc/letsencrypt/live/mcp.yourdomain.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/mcp.yourdomain.com/privkey.pem;\n    \n    # Security headers\n    add_header X-Frame-Options \"SAMEORIGIN\" always;\n    add_header X-Content-Type-Options \"nosniff\" always;\n    add_header X-XSS-Protection \"1; mode=block\" always;\n\n    # MCP Server proxy\n    location / {\n        proxy_http_version 1.1;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"upgrade\";\n        \n        # Important for SSE connections\n        proxy_buffering off;\n        proxy_cache off;\n        \n        proxy_pass http://127.0.0.1:8080/;\n    }\n}\n\n# Redirect HTTP to HTTPS\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name mcp.yourdomain.com;\n    return 301 https://$server_name$request_uri;\n}\n```\n\n**Start Services:**\n```bash\n# Enable and start supervisor\nsudo supervisorctl reread\nsudo supervisorctl update\nsudo supervisorctl start mcp-server:*\n\n# Enable and start nginx\nsudo systemctl enable nginx\nsudo systemctl restart nginx\n\n# Check status\nsudo supervisorctl status\n```\n\n**Client Configuration:**\n```json\n{\n  \"mcpServers\": {\n    \"my-server\": {\n      \"url\": \"https://mcp.yourdomain.com/mcp\"\n    }\n  }\n}\n```\n\n### Option 2: Docker Deployment\n\n**Best for**: Containerized environments, Kubernetes, cloud platforms\n\n**Production Dockerfile:**\n```dockerfile\nFROM php:8.3-fpm-alpine\n\n# Install system dependencies\nRUN apk --no-cache add \\\n    nginx \\\n    supervisor \\\n    && docker-php-ext-enable opcache\n\n# Install PHP extensions for MCP\nRUN docker-php-ext-install pdo_mysql pdo_sqlite opcache\n\n# Create application directory\nWORKDIR /var/www/mcp\n\n# Copy application code\nCOPY . /var/www/mcp\nCOPY docker/nginx.conf /etc/nginx/nginx.conf\nCOPY docker/supervisord.conf /etc/supervisord.conf\nCOPY docker/php.ini /usr/local/etc/php/conf.d/production.ini\n\n# Install Composer dependencies\nRUN composer install --no-dev --optimize-autoloader --no-interaction\n\n# Set permissions\nRUN chown -R www-data:www-data /var/www/mcp\n\n# Expose port\nEXPOSE 80\n\n# Start supervisor\nCMD [\"/usr/bin/supervisord\", \"-c\", \"/etc/supervisord.conf\"]\n```\n\n**docker-compose.yml:**\n```yaml\nservices:\n  mcp-server:\n    build: .\n    ports:\n      - \"8080:80\"\n    environment:\n      - MCP_ENV=production\n      - MCP_LOG_LEVEL=info\n    volumes:\n      - ./storage:/var/www/mcp/storage\n    restart: unless-stopped\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # Optional: Add database if needed\n  database:\n    image: mysql:8.0\n    environment:\n      MYSQL_ROOT_PASSWORD: secure_password\n      MYSQL_DATABASE: mcp_server\n    volumes:\n      - mysql_data:/var/lib/mysql\n    restart: unless-stopped\n\nvolumes:\n  mysql_data:\n```\n\n### Security Best Practices\n\n1. **Firewall Configuration:**\n```bash\n# Only allow necessary ports\nsudo ufw allow ssh\nsudo ufw allow 80\nsudo ufw allow 443\nsudo ufw deny 8080  # MCP port should not be publicly accessible\nsudo ufw enable\n```\n\n2. **SSL/TLS Setup:**\n```bash\n# Install Certbot for Let's Encrypt\nsudo apt install certbot python3-certbot-nginx\n\n# Generate SSL certificate\nsudo certbot --nginx -d mcp.yourdomain.com\n```\n\n## 📚 Examples & Use Cases\n\nExplore comprehensive examples in the [`examples/`](./examples/) directory:\n\n### Available Examples\n\n- **`01-discovery-stdio-calculator/`** - Basic stdio calculator with attribute discovery\n- **`02-discovery-http-userprofile/`** - HTTP server with user profile management  \n- **`03-manual-registration-stdio/`** - Manual element registration patterns\n- **`04-combined-registration-http/`** - Combining manual and discovered elements\n- **`05-stdio-env-variables/`** - Environment variable handling\n- **`06-custom-dependencies-stdio/`** - Dependency injection with task management\n- **`07-complex-tool-schema-http/`** - Advanced schema validation examples\n- **`08-schema-showcase-streamable/`** - Comprehensive schema feature showcase\n\n### Running Examples\n\n```bash\n# Navigate to an example directory\ncd examples/01-discovery-stdio-calculator/\n\n# Make the server executable\nchmod +x server.php\n\n# Run the server (or configure it in your MCP client)\n./server.php\n```\n\n## 🚧 Migration from v2.x\n\nIf migrating from version 2.x, note these key changes:\n\n### Schema Updates\n- Uses `php-mcp/schema` package for DTOs instead of internal classes\n- Content types moved to `PhpMcp\\Schema\\Content\\*` namespace\n- Updated method signatures for better type safety\n\n### Session Management\n- New session management with multiple backends\n- Use `->withSession()` or `->withSessionHandler()` for configuration\n- Sessions are now persistent across reconnections (with cache backend)\n\n### Transport Changes\n- New `StreamableHttpServerTransport` with resumability\n- Enhanced error handling and event sourcing\n- Better batch request processing\n\n## 🧪 Testing\n\n```bash\n# Install development dependencies\ncomposer install --dev\n\n# Run the test suite\ncomposer test\n\n# Run tests with coverage (requires Xdebug)\ncomposer test:coverage\n\n# Run code style checks\ncomposer lint\n```\n\n## 🤝 Contributing\n\nWe welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\n\n## 📄 License\n\nThe MIT License (MIT). See [LICENSE](LICENSE) for details.\n\n## 🙏 Acknowledgments\n\n- Built on the [Model Context Protocol](https://modelcontextprotocol.io/) specification\n- Powered by [ReactPHP](https://reactphp.org/) for async operations\n- Uses [PSR standards](https://www.php-fig.org/) for maximum interoperability\n\n---\n\n**Ready to build powerful MCP servers with PHP?** Start with our [Quick Start](#-quick-start-stdio-server-with-discovery) guide! 🚀\n\n"
}