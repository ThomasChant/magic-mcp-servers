{
  "mcp_name": "luminati-io/web-scraping-with-mcp",
  "mcp_description": "Connects Anthropic LLMs to external web scraping tools using Bright Data integration for real-world data extraction.",
  "mcp_id": "luminati-io_web-scraping-with-mcp",
  "fetch_timestamp": "2025-06-23T06:18:21.390200Z",
  "github_url": "https://github.com/luminati-io/web-scraping-with-mcp",
  "repository": {
    "name": "web-scraping-with-mcp",
    "full_name": "luminati-io/web-scraping-with-mcp",
    "description": "Example MCP server and instructions for connecting Anthropic LLMs to external web scraping tools, with real-world examples and Bright Data integration.",
    "html_url": "https://github.com/luminati-io/web-scraping-with-mcp",
    "created_at": "2025-04-28T10:18:10Z",
    "updated_at": "2025-06-02T11:37:01Z",
    "pushed_at": "2025-04-28T11:01:18Z",
    "size": 3333,
    "stargazers_count": 1,
    "watchers_count": 1,
    "forks_count": 1,
    "open_issues_count": 0,
    "language": null,
    "license": null,
    "topics": [
      "anthropic-claude",
      "claude",
      "mcp",
      "scraping-mcp",
      "web-scraping"
    ],
    "default_branch": "main",
    "owner": {
      "login": "luminati-io",
      "type": "Organization",
      "avatar_url": "https://avatars.githubusercontent.com/u/19207323?v=4",
      "html_url": "https://github.com/luminati-io"
    },
    "has_issues": true,
    "has_projects": true,
    "has_downloads": true,
    "has_wiki": false,
    "has_pages": false,
    "archived": false,
    "disabled": false,
    "visibility": "public",
    "network_count": 1,
    "subscribers_count": 0,
    "pull_requests_count": 0,
    "contributors_count": 1
  },
  "readme": "# Web Scraping with Anthropic’s MCP\n\n[![Bright Data Promo](https://github.com/luminati-io/LinkedIn-Scraper/raw/main/Proxies%20and%20scrapers%20GitHub%20bonus%20banner.png)](https://brightdata.com/)\n\nThis guide explains how to set up an MCP server for on-demand data extraction, connect with development tools, and leverage Bright Data for instant AI-compatible web information.\n\n- [Understanding the Limitation: Why LLMs Need Help with Real-World Interaction](#understanding-the-limitation-why-llms-need-help-with-real-world-interaction)\n- [The Importance of MCP](#the-importance-of-mcp)\n- [Understanding Model Context Protocol](#understanding-model-context-protocol)\n- [MCP Architecture Explained](#mcp-architecture-explained)\n- [Developing Your Own MCP Server](#developing-your-own-mcp-server)\n- [Connecting Your MCP Server](#connecting-your-mcp-server)\n- [Using Bright Data's MCP for Professional Web Data Extraction](#using-bright-datas-mcp-for-professional-web-data-extraction)\n- [Further Reading](#further-reading)\n\n## Understanding the Limitation: Why LLMs Need Help with Real-World Interaction\n\nLarge Language Models (LLMs) excel at processing and generating text from extensive training datasets. However, they face a critical constraint—they cannot naturally interact with the external world. This means they lack built-in capabilities to access local files, execute custom scripts, or retrieve current information from websites.\n\nConsider a basic example: asking Claude to extract details from an active Amazon product page is impossible without additional tools. Why? Because it doesn't have the inherent capability to browse the internet or trigger external actions.\n\n![claude-without-mcp](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-without-mcp.png)\n\nWithout supplementary tooling, LLMs cannot perform practical tasks that depend on real-time data or integration with external systems.\n\nThis is where [Anthropic's Model Context Protocol (MCP)](https://www.anthropic.com/news/model-context-protocol) becomes valuable. It enables LLMs to communicate with external tools—like data extractors, APIs, or scripts—in a secure and standardized manner.\n\nHere's the difference in action. After integrating a custom MCP server, we successfully extracted structured Amazon product information directly through Claude:\n\n![claude-amazon-product-data-extraction-results](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-amazon-product-data-extraction-results.png)\n\n## The Importance of MCP\n\n- **Standardization:** MCP provides a uniform interface for LLM-based systems to connect with external tools and data—similar to how APIs standardized web integrations. This significantly reduces the need for custom integrations, accelerating development.\n- **Flexibility and Scalability:** Developers can replace LLMs or hosting platforms without rewriting tool integrations. MCP supports multiple communication methods (such as `stdio`), making it adaptable to various configurations.\n- **Enhanced LLM Capabilities:** By connecting LLMs to current data and external tools, MCP allows them to go beyond static responses. They can now deliver up-to-date, relevant information and trigger real-world actions based on context.\n\n> **Analogy**:\n> \n> Think of MCP as a USB interface for LLMs. Just like USB allows different devices (keyboards, printers, external drives) to plug into any compatible machine without needing special drivers, MCP lets LLMs connect to a wide range of tools using a standardized protocol—no need for custom integration each time.\n\n## Understanding Model Context Protocol\n\nModel Context Protocol (MCP) is an open standard developed by Anthropic that enables large language models (LLMs) to interact with external tools, APIs, and data sources in a consistent, secure way. It functions as a universal connector, allowing LLMs to perform real-world tasks like extracting website data, querying databases, or executing scripts.\n\nWhile Anthropic introduced it, MCP is open and extensible, meaning anyone can implement or contribute to the standard. If you've worked with [Retrieval-Augmented Generation (RAG)](https://brightdata.com/blog/web-data/rag-explained), you'll appreciate the concept. MCP builds on that idea by standardizing interactions through a lightweight JSON-RPC interface so models can access live data and take action.\n\n## MCP Architecture Explained\n\nAt its foundation, MCP standardizes communication between an AI model and external capabilities.\n\n**Core Idea:** A standardized interface (usually JSON-RPC 2.0 over transports like `stdio`) allows an LLM (via a client) to discover and invoke tools exposed by external servers.\n\nMCP operates through a client-server architecture with three key components:\n\n1. **MCP Host**: The environment or application that initiates and manages interactions between the LLM and external tools. Examples include AI assistants like _Claude Desktop_ or IDEs like _Cursor_.\n2. **MCP Client**: A component within the host that establishes and maintains connections with MCP Servers, handling the communication protocols and managing data exchange.\n3. **MCP Server:** A program (which we developers create) that implements the MCP protocol and exposes a specific set of capabilities. An MCP server might interface with a database, a web service, or, in our case, a website (Amazon). Servers expose their functionality in standardized ways:\n   - **Tools:** Callable functions (e.g. _scrape\\_amazon\\_product_, _get\\_weather\\_data_)\n   - **Resources:** Read-only endpoints for retrieving static data (e.g. fetch a file, return a JSON record)\n   - **Prompts:** Predefined templates to guide LLM interaction with tools and resources\n\nHere's the MCP architecture diagram:\n\n![mcp-architecture-diagram-host-client-server-connections](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/mcp-architecture-diagram-host-client-server-connections.png)\n\n_Image Source: [Model Context Protocol](https://modelcontextprotocol.io/introduction)_\n\nIn this setup, the **host** (Claude Desktop or Cursor IDE) spawns an **MCP client**, which then connects to an external **MCP server**. That server exposes tools, resources, and prompts, allowing the AI to interact with them as needed.\n\nIn short, the workflow operates as follows:\n\n- The user sends a message like _\"Fetch product info from this Amazon link.\"_\n- The MCP client checks for a registered tool that can handle that task\n- The client sends a structured request to the MCP server\n- The MCP server executes the appropriate action (e.g., launching a headless browser)\n- The server returns structured results to the MCP client\n- The client forwards the results to the LLM, which presents them to the user\n\n## Developing Your Own MCP Server\n\nLet's construct a Python MCP server to extract data from Amazon product pages.\n\n![amazon-product-page-example](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/amazon-product-page-example.png)\n\nThis server will offer two tools: one to download HTML and another to extract organized information. You'll interact with the server via an LLM client in Cursor or Claude Desktop.\n\n### Step 1: Preparing Your Environment\n\nFirst, verify you have [Python 3](https://www.python.org/downloads/) installed. Then, create and activate a virtual environment:\n\n```sh\npython -m venv mcp-amazon-scraper\n# On macOS/Linux:\nsource mcp-amazon-scraper/bin/activate\n# On Windows:\n.\\mcp-amazon-scraper\\Scripts\\activate\n```\n\nInstall the necessary libraries: the [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk), [Playwright](https://playwright.dev/python/), and [LXML](https://lxml.de/).\n\n```sh\npip install mcp playwright lxml\n# Install browser binaries for Playwright\npython -m playwright install\n```\n\nThis installs:\n\n- **mcp**: Python SDK for Model Context Protocol servers and clients that handles all the JSON-RPC communication details\n- **playwright**: Browser automation library that provides headless browser capabilities for rendering and scraping JavaScript-heavy websites\n- **lxml**: Fast XML/HTML parsing library that makes it easy to extract specific data elements from web pages using XPath queries\n\nIn short, the MCP Python SDK (`mcp`) handles all protocol details, letting you expose tools that Claude or Cursor can call via natural-language prompts. Playwright allows us to render web pages completely (including JavaScript content), and lxml gives us powerful HTML parsing capabilities.\n\n### Step 2: Starting the MCP Server\n\nCreate a Python file named `amazon_scraper_mcp.py`. Begin by importing the required modules and initializing the `FastMCP` server:\n\n```python\nimport os\nimport asyncio\nfrom lxml import html as lxml_html\nfrom mcp.server.fastmcp import FastMCP\nfrom playwright.async_api import async_playwright\n\n# Define a temporary file path for the HTML content\nHTML_FILE = os.path.join(os.getenv(\"TMPDIR\", \"/tmp\"), \"amazon_product_page.html\")\n\n# Initialize the MCP server with a descriptive name\nmcp = FastMCP(\"Amazon Product Scraper\")\n\nprint(\"MCP Server Initialized: Amazon Product Scraper\")\n```\n\nThis creates an instance of the MCP server. We'll now add tools to it.\n\n### Step 3: Implementing the `fetch_page` Tool\n\nThis tool will take a URL as input, use Playwright to navigate to the page, wait for the content to load, download the HTML, and save it to our temporary file.\n\n```python\n@mcp.tool()\nasync def fetch_page(url: str) -> str:\n    \"\"\"\n    Fetches the HTML content of the given Amazon product URL using Playwright\n    and saves it to a temporary file. Returns a status message.\n    \"\"\"\n    print(f\"Executing fetch_page for URL: {url}\")\n    try:\n        async with async_playwright() as p:\n            # Launch headless Chromium browser\n            browser = await p.chromium.launch(headless=True)\n            page = await browser.new_page()\n            # Navigate to the URL with a generous timeout\n            await page.goto(url, timeout=90000, wait_until=\"domcontentloaded\")\n            # Wait for a key element (e.g., body) to ensure basic loading\n            await page.wait_for_selector(\"body\", timeout=30000)\n            # Add a small delay for any dynamic content rendering via JavaScript\n            await asyncio.sleep(5)\n\n            html_content = await page.content()\n            with open(HTML_FILE, \"w\", encoding=\"utf-8\") as f:\n                f.write(html_content)\n\n            await browser.close()\n            print(f\"Successfully fetched and saved HTML to {HTML_FILE}\")\n            return f\"HTML content for {url} downloaded and saved successfully to {HTML_FILE}.\"\n    except Exception as e:\n        error_message = f\"Error fetching page {url}: {str(e)}\"\n        print(error_message)\n        return error_message\n```\n\nThis asynchronous function uses Playwright to handle potential JavaScript rendering on Amazon pages. The `@mcp.tool()` decorator registers this function as a callable tool within our server.\n\n### Step 4: Implementing the `extract_info` Tool\n\nThis tool reads the HTML file saved by `fetch_page`, parses it using LXML and XPath selectors, and returns a dictionary containing the extracted product details.\n\n```python\ndef _extract_xpath(tree, xpath, default=\"N/A\"):\n    \"\"\"Helper function to extract text using XPath, returning default if not found.\"\"\"\n    try:\n        # Use text_content() to get text from node and children, strip whitespace\n        result = tree.xpath(xpath)\n        if result:\n            return result[0].text_content().strip()\n        return default\n    except Exception:\n        return default\n\ndef _extract_price(price_str):\n    \"\"\"Helper function to parse price string into a float.\"\"\"\n    if price_str == \"N/A\":\n        return None\n    try:\n        # Remove currency symbols and commas, handle potential whitespace\n        cleaned_price = \"\".join(filter(str.isdigit or str.__eq__(\".\"), price_str))\n        return float(cleaned_price)\n    except (ValueError, TypeError):\n        return None\n\n@mcp.tool()\ndef extract_info() -> dict:\n    \"\"\"\n    Parses the saved HTML file (downloaded by fetch_page) to extract\n    Amazon product details like title, price, rating, features, etc.\n    Returns a dictionary of the extracted data.\n    \"\"\"\n    print(f\"Executing extract_info from file: {HTML_FILE}\")\n    if not os.path.exists(HTML_FILE):\n        return {\n            \"error\": f\"HTML file not found at {HTML_FILE}. Please run fetch_page first.\"\n        }\n\n    try:\n        with open(HTML_FILE, \"r\", encoding=\"utf-8\") as f:\n            page_html = f.read()\n\n        tree = lxml_html.fromstring(page_html)\n\n        # --- XPath Selectors for Amazon Product Details ---\n        title = _extract_xpath(tree, '//span[@id=\"productTitle\"]')\n        # Handle different price structures (main price, sale price)\n        price_whole = _extract_xpath(tree, '//span[contains(@class, \"a-price-whole\")]')\n        price_fraction = _extract_xpath(\n            tree, '//span[contains(@class, \"a-price-fraction\")]'\n        )\n        price_str = (\n            f\"{price_whole}.{price_fraction}\"\n            if price_whole != \"N/A\"\n            else _extract_xpath(tree, '//span[contains(@class,\"a-offscreen\")]')\n        )  # Fallback to offscreen if needed\n\n        price = _extract_price(price_str)\n\n        # Original price (strike-through)\n        original_price_str = _extract_xpath(\n            tree, '//span[@class=\"a-price a-text-price\"]//span[@class=\"a-offscreen\"]'\n        )\n        original_price = _extract_price(original_price_str)\n\n        # Rating\n        rating_text = _extract_xpath(tree, '//span[@id=\"acrPopover\"]/@title')\n        rating = None\n        if rating_text != \"N/A\":\n            try:\n                rating = float(rating_text.split()[0])\n            except (ValueError, IndexError):\n                rating = None\n\n        # Review Count\n        reviews_text = _extract_xpath(tree, '//span[@id=\"acrCustomerReviewText\"]')\n        review_count = None\n        if reviews_text != \"N/A\":\n            try:\n                review_count = int(reviews_text.split()[0].replace(\",\", \"\"))\n            except (ValueError, IndexError):\n                review_count = None\n\n        # Availability\n        availability = _extract_xpath(\n            tree,\n            '//div[@id=\"availability\"]//span/text()',\n        )\n\n        # Features (bullet points)\n        feature_elements = tree.xpath(\n            '//div[@id=\"feature-bullets\"]//li//span[@class=\"a-list-item\"]'\n        )\n        features = [\n            elem.text_content().strip()\n            for elem in feature_elements\n            if elem.text_content().strip()\n        ]\n\n        # Calculate Discount\n        discount = None\n        if price and original_price and original_price > price:\n            discount = round(((original_price - price) / original_price) * 100)\n\n        extracted_data = {\n            \"title\": title,\n            \"price\": price,\n            \"original_price\": original_price,\n            \"discount_percent\": discount,\n            \"rating_stars\": rating,\n            \"review_count\": review_count,\n            \"features\": features,\n            \"availability\": availability.strip(),\n        }\n        print(f\"Successfully extracted data: {extracted_data}\")\n        return extracted_data\n\n    except Exception as e:\n        error_message = f\"Error parsing HTML: {str(e)}\"\n        print(error_message)  # Added for logging\n        return {\"error\": error_message}\n```\n\nThis function uses LXML's `fromstring` to parse the HTML and robust XPath selectors to find the desired elements\n\n### Step 5: Running the Server\n\nFinally, add the following lines to the end of your `amazon_scraper_mcp.py` script to start the server using the `stdio` transport mechanism, which is standard for local MCP servers communicating with clients like Claude Desktop or Cursor.\n\n```python\nif __name__ == \"__main__\":\n    print(\"Starting MCP Server with stdio transport...\")\n    # Run the server, listening via standard input/output\n    mcp.run(transport=\"stdio\")\n```\n\n### Complete Source Code\n\n```python\nimport os\nimport asyncio\nfrom lxml import html as lxml_html\nfrom mcp.server.fastmcp import FastMCP\nfrom playwright.async_api import async_playwright\n\n# Define a temporary file path for the HTML content\nHTML_FILE = os.path.join(os.getenv(\"TMPDIR\", \"/tmp\"), \"amazon_product_page.html\")\n\n# Initialize the MCP server with a descriptive name\nmcp = FastMCP(\"Amazon Product Scraper\")\n\nprint(\"MCP Server Initialized: Amazon Product Scraper\")\n\n@mcp.tool()\nasync def fetch_page(url: str) -> str:\n    \"\"\"\n    Fetches the HTML content of the given Amazon product URL using Playwright\n    and saves it to a temporary file. Returns a status message.\n    \"\"\"\n    print(f\"Executing fetch_page for URL: {url}\")\n    try:\n        async with async_playwright() as p:\n            # Launch headless Chromium browser\n            browser = await p.chromium.launch(headless=True)\n            page = await browser.new_page()\n            # Navigate to the URL with a generous timeout\n            await page.goto(url, timeout=90000, wait_until=\"domcontentloaded\")\n            # Wait for a key element (e.g., body) to ensure basic loading\n            await page.wait_for_selector(\"body\", timeout=30000)\n            # Add a small delay for any dynamic content rendering via JavaScript\n            await asyncio.sleep(5)\n\n            html_content = await page.content()\n            with open(HTML_FILE, \"w\", encoding=\"utf-8\") as f:\n                f.write(html_content)\n\n            await browser.close()\n            print(f\"Successfully fetched and saved HTML to {HTML_FILE}\")\n            return f\"HTML content for {url} downloaded and saved successfully to {HTML_FILE}.\"\n    except Exception as e:\n        error_message = f\"Error fetching page {url}: {str(e)}\"\n        print(error_message)\n        return error_message\n\ndef _extract_xpath(tree, xpath, default=\"N/A\"):\n    \"\"\"Helper function to extract text using XPath, returning default if not found.\"\"\"\n    try:\n        # Use text_content() to get text from node and children, strip whitespace\n        result = tree.xpath(xpath)\n        if result:\n            return result[0].text_content().strip()\n        return default\n    except Exception:\n        return default\n\ndef _extract_price(price_str):\n    \"\"\"Helper function to parse price string into a float.\"\"\"\n    if price_str == \"N/A\":\n        return None\n    try:\n        # Remove currency symbols and commas, handle potential whitespace\n        cleaned_price = \"\".join(filter(str.isdigit or str.__eq__(\".\"), price_str))\n        return float(cleaned_price)\n    except (ValueError, TypeError):\n        return None\n\n@mcp.tool()\ndef extract_info() -> dict:\n    \"\"\"\n    Parses the saved HTML file (downloaded by fetch_page) to extract\n    Amazon product details like title, price, rating, features, etc.\n    Returns a dictionary of the extracted data.\n    \"\"\"\n    print(f\"Executing extract_info from file: {HTML_FILE}\")\n    if not os.path.exists(HTML_FILE):\n        return {\n            \"error\": f\"HTML file not found at {HTML_FILE}. Please run fetch_page first.\"\n        }\n\n    try:\n        with open(HTML_FILE, \"r\", encoding=\"utf-8\") as f:\n            page_html = f.read()\n\n        tree = lxml_html.fromstring(page_html)\n\n        # --- XPath Selectors for Amazon Product Details ---\n        title = _extract_xpath(tree, '//span[@id=\"productTitle\"]')\n        # Handle different price structures (main price, sale price)\n        price_whole = _extract_xpath(tree, '//span[contains(@class, \"a-price-whole\")]')\n        price_fraction = _extract_xpath(\n            tree, '//span[contains(@class, \"a-price-fraction\")]'\n        )\n        price_str = (\n            f\"{price_whole}.{price_fraction}\"\n            if price_whole != \"N/A\"\n            else _extract_xpath(tree, '//span[contains(@class,\"a-offscreen\")]')\n        )  # Fallback to offscreen if needed\n\n        price = _extract_price(price_str)\n\n        # Original price (strike-through)\n        original_price_str = _extract_xpath(\n            tree, '//span[@class=\"a-price a-text-price\"]//span[@class=\"a-offscreen\"]'\n        )\n        original_price = _extract_price(original_price_str)\n\n        # Rating\n        rating_text = _extract_xpath(tree, '//span[@id=\"acrPopover\"]/@title')\n        rating = None\n        if rating_text != \"N/A\":\n            try:\n                rating = float(rating_text.split()[0])\n            except (ValueError, IndexError):\n                rating = None\n\n        # Review Count\n        reviews_text = _extract_xpath(tree, '//span[@id=\"acrCustomerReviewText\"]')\n        review_count = None\n        if reviews_text != \"N/A\":\n            try:\n                review_count = int(reviews_text.split()[0].replace(\",\", \"\"))\n            except (ValueError, IndexError):\n                review_count = None\n\n        # Availability\n        availability = _extract_xpath(\n            tree,\n            '//div[@id=\"availability\"]//span/text()',\n        )\n\n        # Features (bullet points)\n        feature_elements = tree.xpath(\n            '//div[@id=\"feature-bullets\"]//li//span[@class=\"a-list-item\"]'\n        )\n        features = [\n            elem.text_content().strip()\n            for elem in feature_elements\n            if elem.text_content().strip()\n        ]\n\n        # Calculate Discount\n        discount = None\n        if price and original_price and original_price > price:\n            discount = round(((original_price - price) / original_price) * 100)\n\n        extracted_data = {\n            \"title\": title,\n            \"price\": price,\n            \"original_price\": original_price,\n            \"discount_percent\": discount,\n            \"rating_stars\": rating,\n            \"review_count\": review_count,\n            \"features\": features,\n            \"availability\": availability.strip(),\n        }\n        print(f\"Successfully extracted data: {extracted_data}\")\n        return extracted_data\n\n    except Exception as e:\n        error_message = f\"Error parsing HTML: {str(e)}\"\n        print(error_message)  # Added for logging\n        return {\"error\": error_message}\n\nif __name__ == \"__main__\":\n    print(\"Starting MCP Server with stdio transport...\")\n    # Run the server, listening via standard input/output\n    mcp.run(transport=\"stdio\")\n```\n\n## Connecting Your MCP Server\n\nNow that the server script is ready, let's connect it to MCP clients like Claude Desktop and Cursor.\n\n### Setting Up with Claude Desktop\n\n**Step 1:** Open Claude Desktop.\n\n**Step 2:** Navigate to `Settings` -> `Developer` -> `Edit Config`. This will open the `claude_desktop_config.json` file in your default text editor.\n\n![claude-desktop-settings-menu-navigation](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-desktop-settings-menu-navigation.png)\n\n**Step 3:** Add an entry for your server under the `mcpServers` key. Make sure to replace the path in `args` with the absolute path to your `amazon_scraper_mcp.py` file.\n\n```json\n{\n  \"mcpServers\": {\n    \"amazon_product_scraper\": {\n      \"command\": \"python\",  // Or python3 if needed\n      \"args\": [\"/full/path/to/your/amazon_scraper_mcp.py\"], // <-- IMPORTANT: Use the correct absolute path\n    }\n  }\n}\n```\n\n**Step 4:** Save the `claude_desktop_config.json` file and completely close and reopen Claude Desktop for the changes to take effect.\n\n**Step 5:** In Claude Desktop, you should now see a small tools icon (like a hammer 🔨) in the chat input area.\n\n![claude-desktop-mcp-tools-icon-interface](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-desktop-mcp-tools-icon-interface.png)\n\n**Step 6:** Clicking it should list your \"Amazon Product Scraper\" with its `fetch_page` and `extract_info` tools.\n\n![claude-available-mcp-tools-dialog-amazon-scraper](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-available-mcp-tools-dialog-amazon-scraper.png)\n\n**Step 7:** Send a Prompt, for example: _\"Get the current price, original price, and rating for this Amazon product: [https://www.amazon.com/dp/B09C13PZX7](https://www.amazon.com/dp/B09C13PZX7)\"._\n\n**Step 8:** Claude will detect that this requires external tools and prompt you for permission to run `fetch_page` first and then `extract_info`. Click \"Allow for this chat\" for each tool.\n\n![mcp-permission-dialog-fetch-page-amazon-tool](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/mcp-permission-dialog-fetch-page-amazon-tool.png)\n\n**Step 9:** After granting permissions, the MCP server will execute the tools. Claude will then receive the structured data and present it in the chat.\n\n![claude-amazon-product-data-extraction-results](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-amazon-product-data-extraction-results-2.png)\n\n### Setting Up with Cursor\n\nThe process for Cursor (an AI-first IDE) is similar.\n\n**Step 1:** Open Cursor.\n\n**Step 2:** Go to `Settings` ⚙️ and navigate the `MCP` section.\n\n![cursor-ide-add-new-global-mcp-server-settings](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/cursor-ide-add-new-global-mcp-server-settings.png)\n\n**Step 3:** Click \"+Add a new global MCP Server\". This will open the `mcp.json` configuration file. Add an entry for your server, again using the **absolute path** to your script.\n\n![cursor-mcp-json-configuration-file-amazon-scraper](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/cursor-mcp-json-configuration-file-amazon-scraper.png)\n\n**Step 4:** Save the `mcp.json` file and you should see your \"amazon\\_product\\_scraper\" listed, hopefully with a green dot indicating it's running and connected.\n\n![cursor-ide-configured-amazon-scraper-mcp-settings](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/cursor-ide-configured-amazon-scraper-mcp-settings.png)\n\n**Step 5:** Use Cursor's chat feature (`Cmd+l` or `Ctrl+l`).\n\n**Step 6:** Send a Prompt, for example: \"_Extract all available product data from this Amazon URL: [https://www.amazon.com/dp/B09C13PZX7](https://www.amazon.com/dp/B09C13PZX7). Format the output as a structured JSON object\"._\n\n**Step 7:** Similar to Claude Desktop, the Cursor will ask for permission to run the `fetch_page` and `extract_info` tools. Approve these requests (\"Run Tool\").\n\n**Step 8:** The Cursor will display the interaction flow, showing the calls to your MCP tools and finally presenting the structured JSON data returned by your `extract_info` tool.\n\n![cursor-ide-amazon-product-data-extraction-json-results](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/cursor-ide-amazon-product-data-extraction-json-results.png)\nHere's an example of JSON output from Cursor:\n\n```json\n{\n  \"title\": \"Razer Basilisk V3 Customizable Ergonomic Gaming Mouse: Fastest Gaming Mouse Switch - Chroma RGB Lighting - 26K DPI Optical Sensor - 11 Programmable Buttons - HyperScroll Tilt Wheel - Classic Black\",\n  \"price\": 39.99,\n  \"original_price\": 69.99,\n  \"discount_percent\": 43,\n  \"rating_stars\": 4.6,\n  \"review_count\": 7782,\n  \"features\": [\n    \"ICONIC ERGONOMIC DESIGN WITH THUMB REST — PC gaming mouse favored by millions worldwide with a form factor that perfectly supports the hand while its buttons are optimally positioned for quick and easy access\",\n    \"11 PROGRAMMABLE BUTTONS — Assign macros and secondary functions across 11 programmable buttons to execute essential actions like push-to-talk, ping, and more\",\n    \"HYPERSCROLL TILT WHEEL — Speed through content with a scroll wheel that free-spins until its stopped or switch to tactile mode for more precision and satisfying feedback that's ideal for cycling through weapons or skills\",\n    \"11 RAZER CHROMA RGB LIGHTING ZONES — Customize each zone from over 16.8 million colors and countless lighting effects, all while it reacts dynamically with over 150 Chroma integrated games\",\n    \"OPTICAL MOUSE SWITCHES GEN 2 — With zero unintended misclicks these switches provide crisp, responsive execution at a blistering 0.2ms actuation speed for up to 70 million clicks\",\n    \"FOCUS+ 26K DPI OPTICAL SENSOR — Best-in-class mouse sensor with intelligent functions flawlessly tracks movement with zero smoothing, allowing for crisp response and pixel-precise accuracy\",\n    // ... (other features)\n  ],\n  \"availability\": \"In Stock\"\n}\n```\n\nThis shows the flexibility of MCP – the same server works seamlessly with different client applications.\n\n## Using Bright Data's MCP for Professional Web Data Extraction\n\nBright Data’s enterprise-grade [Model Context Protocol (MCP)](https://github.com/luminati-io/brightdata-mcp) solution eliminates the complexities of self-managed MCP servers—such as proxy management, [anti-bot navigation](https://brightdata.com/blog/web-data/anti-scraping-techniques), and scaling challenges—offering seamless integration with [AI agents](https://brightdata.com/use-cases/apps-agents) and LLMs.\n\nConnecting to Bright Data’s MCP enables immediate access to public web data, including SERP results and hard-to-reach sites, optimized for AI workflows.\n\nMCP unlocks a powerful web extraction framework with tools like the [Web Unlocker](https://brightdata.com/products/web-unlocker), [SERP API](https://brightdata.com/products/serp-api), [Web Scraper API](https://brightdata.com/products/web-scraper), and [Scraping Browser](https://brightdata.com/products/scraping-browser), delivering:\n\n- **[AI-Ready Data](https://brightdata.com/use-cases/data-for-ai):** Pre-structured content, no preprocessing needed.\n- **Scalability & Reliability:** High-volume support without slowdowns.\n- **Block & CAPTCHA Bypass:** Advanced anti-bot capabilities.\n- **Global IP Coverage:** Access from 195 countries with [Bright Data proxies](https://brightdata.com/proxy-types).\n- **Seamless Integration:** Quick setup with any MCP client.\n\n### Prerequisites for Bright Data MCP\n\nBefore starting your Bright Data MCP integration, verify you have the following:\n\n1. **Bright Data Account:** Register at [brightdata.com](https://brightdata.com/). First-time users receive complimentary credits for testing.\n2. **API Token:** Secure your API token from your Bright Data account settings ([User Settings Page](https://brightdata.com/cp/setting/users)).\n3. **Web Unlocker Zone:** [Establish a Web Unlocker proxy](https://docs.brightdata.com/scraping-automation/web-unlocker/quickstart) zone in your Bright Data control panel. Choose a memorable identifier, such as `mcp_unlocker` (this can be modified later via environment variables if necessary).\n4. **(Optional) Scraping Browser Zone:** If you require advanced browser automation features (e.g., for intricate JavaScript interactions or screenshots), [establish a Scraping Browser zone](https://docs.brightdata.com/scraping-automation/scraping-browser/quickstart). Record the authentication details (Username and Password) provided for this zone (within the **Overview** tab), typically formatted as `brd-customer-ACCOUNT_ID-zone-ZONE_NAME:PASSWORD`.\n\n### Quickstart: Configuring Bright Data MCP for Claude Desktop\n\n**Step 1:** The Bright Data MCP server typically runs using `npx`, which comes bundled with Node.js. Install Node.js if needed from the [official website](https://nodejs.org/en/download).\n\n**Step 2:** Open Claude Desktop -> `Settings` -> `Developer` -> `Edit Config` (`claude_desktop_config.json`).\n\n**Step 3:** Insert the Bright Data server configuration under `mcpServers`. Substitute placeholders with your actual credentials.\n\n```json\n{\n  \"mcpServers\": {\n    \"Bright Data\": { // Choose a name for the server\n      \"command\": \"npx\",\n      \"args\": [\"@brightdata/mcp\"],\n      \"env\": {\n        \"API_TOKEN\": \"YOUR_BRIGHTDATA_API_TOKEN\", // Paste your API token here\n        \"WEB_UNLOCKER_ZONE\": \"mcp_unlocker\",     // Your Web Unlocker zone name\n        // Optional: Add if using Scraping Browser tools\n        \"BROWSER_AUTH\": \"brd-customer-ACCOUNTID-zone-YOURZONE:PASSWORD\"\n      }\n    }\n  }\n}\n```\n\n**Step 4:** Save the configuration file and restart Claude Desktop.\n\n**Step 5:** Hover over the hammer icon (🔨) in Claude Desktop. You should now see multiple MCP tools available.\n\n![claude-desktop-interface-with-mcp-tools-available](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/claude-desktop-interface-with-mcp-tools-available.png)\n\nLet's attempt to extract data from Zillow, a website known for potentially restricting scrapers. Prompt Claude with \"_Extract key property data in JSON format from this Zillow URL: [https://www.zillow.com/apartments/arverne-ny/the-tides-at-arverne-by-the-sea/ChWHPZ/](https://www.zillow.com/apartments/arverne-ny/the-tides-at-arverne-by-the-sea/ChWHPZ/)_\"\n\n![bright-data-mcp-zillow-property-extraction-process](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/bright-data-mcp-zillow-property-extraction-process.png)\n\nPermit Claude to utilize the necessary Bright Data MCP tools. Bright Data's MCP server will manage the underlying complexities (proxy rotation, JavaScript rendering via Scraping Browser if required).\n\nBright Data's server conducts the extraction and delivers structured data, which Claude presents.\n\n![zillow-property-data-json-structure-bright-data-mcp](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/zillow-property-data-json-structure-bright-data-mcp.png)\n\nHere's a sample of the potential output:\n\n```json\n{\n  \"propertyInfo\": {\n    \"name\": \"The Tides At Arverne By The Sea\",\n    \"address\": \"190 Beach 69th St, Arverne, NY 11692\",\n    \"propertyType\": \"Apartment building\",\n    // ... more info\n  },\n  \"rentPrices\": {\n    \"studio\": { \"startingPrice\": \"$2,750\", /* ... */ },\n    \"oneBed\": { \"startingPrice\": \"$2,900\", /* ... */ },\n    \"twoBed\": { \"startingPrice\": \"$3,350\", /* ... */ }\n  },\n  // ... amenities, policies, etc.\n}\n```\n\n**Another Example: Hacker News Headlines**\n\nA more straightforward query: \"_Give me the titles of the latest 5 news articles from Hacker News_\".\n\n![hacker-news-latest-articles-mcp-extraction-results](https://github.com/luminati-io/web-scraping-with-mcp/blob/main/images/hacker-news-latest-articles-mcp-extraction-results.png)\n\nThis demonstrates how Bright Data's MCP server simplifies accessing even dynamic or heavily secured web content directly within your AI workflow.\n\n## Further Reading\n\nHere is a curation of our earlier guides on AI and large language models (LLMs) for more in-depth knowledge:\n\n- [Top Sources for Finding LLM Training Data](https://brightdata.com/blog/web-data/llm-training-data)\n- [Web Scraping with LLaMA 3: Turn Any Website into Structured JSON](https://brightdata.com/blog/web-data/web-scraping-with-llama-3)\n- [Web Scraping With LangChain and Bright Data](https://brightdata.com/blog/web-data/web-scraping-with-langchain-and-bright-data)\n- [How To Create a RAG Chatbot With GPT-4o Using SERP Data](https://brightdata.com/blog/web-data/build-a-rag-chatbot)\n\n## Conclusion\n\nAnthropic's Model Context Protocol represents a fundamental shift in how AI systems interact with the external world. You can construct custom MCP servers for specific tasks. Bright Data's MCP integration enhances this further by delivering enterprise-grade web scraping capabilities that evade anti-bot protections and supply [AI-ready structured data](https://brightdata.com/use-cases/data-for-ai).\n\nRegister and try out [AI solutions](https://brightdata.com/ai) today for free!\n"
}