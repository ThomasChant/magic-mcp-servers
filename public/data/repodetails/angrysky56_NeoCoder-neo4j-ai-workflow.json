{
  "mcp_name": "angrysky56/NeoCoder-neo4j-ai-workflow",
  "mcp_description": "Enables AI assistants to utilize a Neo4j knowledge graph for dynamic coding workflows and project memory management.",
  "mcp_id": "angrysky56_NeoCoder-neo4j-ai-workflow",
  "fetch_timestamp": "2025-06-23T01:08:30.127028Z",
  "github_url": "https://github.com/angrysky56/NeoCoder-neo4j-ai-workflow",
  "repository": {
    "name": "NeoCoder-neo4j-ai-workflow",
    "full_name": "angrysky56/NeoCoder-neo4j-ai-workflow",
    "description": "An MCP server allowing AI assistants to use a Neo4j knowledge graph as their primary, dynamic instruction manual and long term project memory with adaptive templating and autonomous tool development tools.",
    "html_url": "https://github.com/angrysky56/NeoCoder-neo4j-ai-workflow",
    "created_at": "2025-04-22T22:19:15Z",
    "updated_at": "2025-06-14T23:00:15Z",
    "pushed_at": "2025-06-14T23:00:12Z",
    "size": 1218,
    "stargazers_count": 4,
    "watchers_count": 4,
    "forks_count": 2,
    "open_issues_count": 0,
    "language": "Python",
    "license": "MIT License",
    "topics": [
      "claude",
      "coder",
      "llm",
      "mcp-server",
      "neo4j",
      "vibe-coding"
    ],
    "default_branch": "main",
    "owner": {
      "login": "angrysky56",
      "type": "User",
      "avatar_url": "https://avatars.githubusercontent.com/u/113643118?v=4",
      "html_url": "https://github.com/angrysky56"
    },
    "has_issues": true,
    "has_projects": true,
    "has_downloads": true,
    "has_wiki": true,
    "has_pages": false,
    "archived": false,
    "disabled": false,
    "visibility": "public",
    "network_count": 2,
    "subscribers_count": 1,
    "languages": {
      "Python": 1126878,
      "Cypher": 26717,
      "Shell": 2783
    },
    "language_percentages": {
      "Python": 97.45,
      "Cypher": 2.31,
      "Shell": 0.24
    },
    "pull_requests_count": 3,
    "contributors_count": 3
  },
  "readme": "[![MseeP.ai Security Assessment Badge](https://mseep.net/pr/angrysky56-neocoder-neo4j-ai-workflow-badge.png)](https://mseep.ai/app/angrysky56-neocoder-neo4j-ai-workflow)\n\n# NeoCoder: Neo4j-Guided AI Coding Workflow\n\nAn MCP server implementation that enables AI assistants like Claude to use a Neo4j knowledge graph as their primary, dynamic \"instruction manual\" and project memory for standardized coding workflows.\n\n## Overview\n\nNeoCoder implements a system where:\n\n1. AI assistants query a Neo4j database for standardized workflows (`ActionTemplates`) triggered by keywords (e.g., `FIX`, `REFACTOR`)\n2. The AI follows specific steps in these templates when performing coding tasks\n3. Critical steps like testing are enforced before logging success\n4. A complete audit trail of changes is maintained in the graph itself\n\nðŸ“ˆ System Status Updated:\n\nThe NeoCoder system now provides sophisticated, protocol-driven workflows for everything from MVP planning to meta-cognitive coding! ðŸš€\n\n## Quick Start\n\n### Prerequisites\n\n- **Neo4j**: Running locally or a remote instance\n- **Python 3.10+**: For running the MCP server\n- **uv**: The Python package manager for MCP servers\n- **Claude Desktop**: For using with Claude AI\n- [MCP-Desktop-Commander](https://github.com/wonderwhy-er/DesktopCommanderMCP): Invaluable For cli and filesystem operations\n- [For the Code Analysis Incarnation: AST/ASG](https://github.com/angrysky56/ast-mcp-server)\n## The MCP server runs the Python code, bridging the gap between the Neo4j graph and the AI assistant ( e.g. Claude)\n\n![alt text](image-3.png)\n\n### Installation\n\n1. It should auto-install when using the config.\n\nOtherwise- Install dependencies:\n\n   ```bash\n   uv venv\n   source .venv/bin/activate\n   # On Windows use `venv\\Scripts\\activate`\n   uv pip install -r requirements.txt\n   ```\n\nIf it doesn't work maybe try:\n   ```bash\n   pip install -e .\n   ```\n\n2. Neo4j connection parameters:\n   - **URL**: `bolt://localhost:7687` (default)\n   - **Username**: `neo4j` (default)\n   - **Password**: Your Neo4j database password\n   - **Database**: `neo4j` (default)\n\n   These can be overridden with environment variables:\n   - `NEO4J_URL`\n   - `NEO4J_USERNAME`\n   - `NEO4J_PASSWORD`\n   - `NEO4J_DATABASE`\n\n3. Claude Desktop Integration:\n\n   Configure Claude Desktop by adding the following to your `claude-app-config.json`:\n\n   ```json\n   {\n     \"mcpServers\": {\n       \"neocoder\": {\n         \"command\": \"uv\",\n         \"args\": [\n           \"--directory\",\n           \"/path/to/your/NeoCoder-neo4j-ai-workflow/src/mcp_neocoder\",\n           \"run\",\n           \"mcp_neocoder\"\n         ],\n         \"env\": {\n           \"NEO4J_URL\": \"bolt://localhost:7687\",\n           \"NEO4J_USERNAME\": \"neo4j\",\n           \"NEO4J_PASSWORD\": \"<YOUR_NEO4J_PASSWORD>\",\n           \"NEO4J_DATABASE\": \"neo4j\"\n         }\n       }\n     }\n   }\n   ```\n\n   **Important**: The password in this configuration must match your Neo4j database password.\n\n## Suggested system prompt\n\n```plaintext\n> **System Instruction:** You are an AI coding assistant integrated with a Neo4j knowledge graph that defines our standard coding procedures and tracks project changes.\n>\n> **Your Core Interaction Loop:**\n> 1.  **Identify Task & Keyword:** Determine the coding action required (e.g., fix a bug -> `FIX`).\n> 2.  **Consult the Hub:** If unsure about keywords or process, start by querying `:AiGuidanceHub {id: 'main_hub'}` for guidance and links to best practices or other guides.\n> 3.  **Retrieve Instructions:** Formulate a Cypher query to fetch the `steps` from the current `:ActionTemplate` matching the keyword (e.g., `MATCH (t:ActionTemplate {keyword: 'FIX', isCurrent: true}) RETURN t.steps`). Execute this query.\n> 4.  **Execute Guided Workflow:** Follow the retrieved `steps` meticulously. This includes reviewing project READMEs, implementing changes, and critically:\n> 5.  **Perform Verification:** Execute the testing steps defined in the template. **ALL required tests MUST pass before you consider the task complete.**\n> 6.  **Record Completion (Post-Testing):** Only if tests pass, formulate and execute the Cypher query specified in the template to create a `:WorkflowExecution` node, linking it appropriately. Do NOT record if tests failed.\n> 7.  **Finalize Updates:** Update the project's README content (in Neo4j or the file) as per the template's instructions.\n>\n> **Strict Rule:** Always prioritize instructions retrieved from the Neo4j graph over your general knowledge for workflow procedures. Use the graph as your single source of truth for *how* tasks are done here.\n```\n\n## Multiple Incarnations\n\nNeoCoder supports multiple \"incarnations\" - different operational modes that adapt the system for specialized use cases while preserving the core Neo4j graph structure. In a graph-native stack, the same Neo4j core can manifest as very different \"brains\" simply by swapping templates and execution policies.\n\n### Key Architectural Principles\n\nThe NeoCoder split is highly adaptable because:\n- Neo4j stores facts as first-class graph objects\n- Workflows live in template nodes\n- Execution engines simply walk the graph\n\nBecause these three tiers are orthogonal, you can freeze one layer while morphing the othersâ€”turning a code-debugger today into a lab notebook or a learning management system tomorrow. This design echoes Neo4j's own \"from graph to knowledge-graph\" maturation path where schema, semantics, and operations are deliberately decoupled.\n\n### Common Graph Schema Motifs\n\nAll incarnations share these core elements:\n\n| Element | Always present | Typical labels / rels |\n|---------|----------------|------------------------|\n| **Actor** | human / agent / tool | `(:Agent)-[:PLAYS_ROLE]->(:Role)` |\n| **Intent** | hypothesis, decision, lesson, scenario | `(:Intent {type})` |\n| **Evidence** | doc, metric, observation | `(:Evidence)-[:SUPPORTS]->(:Intent)` |\n| **Outcome** | pass/fail, payoff, grade, state vector | `(:Outcome)-[:RESULT_OF]->(:Intent)` |\n\n### Available Incarnations:\n\n- **base_incarnation** (default) - Original NeoCoder, Tool, Templates and Incarnations Workflow management\n- **research_incarnation** - Scientific research platform for hypothesis tracking and experiments\n  - Register hypotheses, design experiments, capture runs, and publish outcomes\n  - Neo4j underpins provenance pilots for lab workflows with lineage queries\n- **decision_incarnation** - Decision analysis and evidence tracking system\n  - Create decision alternatives with expected-value metrics\n  - Bayesian updater agents re-compute metric posteriors when new evidence arrives\n  - Transparent, explainable reasoning pipelines\n- **data_analysis_incarnation** - Complex system modeling and simulation\n  - Model components with state vectors and physical couplings\n  - Simulate failure propagation using path queries\n  - Optional quantum-inspired scheduler for parameter testing\n- **knowledge_graph_incarnation** - Knowledge graph management system\n  - Create and manage entities with observations\n  - Connect entities with typed relationships\n  - Search and visualize knowledge structures\n  - Support for complex semantic queries\n- **code_analysis_incarnation** - Code analysis using Abstract Syntax Trees\n  - Parse and analyze code structure using AST and ASG tools\n  - Track code complexity and quality metrics\n  - Compare different versions of code\n  - Generate documentation from code analysis\n  - Identify code smells and potential issues\n\n\nEach incarnation provides its own set of specialized tools that are automatically registered when the server starts. These tools are available for use in Claude or other AI assistants that connect to the MCP server.\n\n### Implementation Roadmap\n\nNeoCoder features an implementation roadmap that includes:\n\n1. **LevelEnv â†” Neo4j Adapter**: Maps events to graph structures and handles batch operations\n2. **Amplitude Register (Quantum Layer)**: Optional quantum-inspired layer for superposition states\n3. **Scheduler**: Prioritizes tasks based on entropy and impact scores\n4. **Re-using TAG assets**: Leverages existing abstractions for vertical information hiding\n\n### Starting with a Specific Incarnation\n\n```bash\n# List all available incarnations\npython -m mcp_neocoder.server --list-incarnations\n\n# Start with a specific incarnation\npython -m mcp_neocoder.server --incarnation continuous_learning\n```\n\nIncarnations can also be switched at runtime using the `switch_incarnation()` tool:\n\n```\nswitch_incarnation(incarnation_type=\"complex_system\")\n```\n\n### Dynamic Incarnation Loading\n\nNeoCoder features a fully dynamic incarnation loading system, which automatically discovers and loads incarnations from the `incarnations` directory. This means:\n\n1. **No hardcoded imports**: New incarnations can be added without modifying server.py\n2. **Auto-discovery**: Just add a new file with the format `*_incarnation.py` to the incarnations directory\n3. **All tools available**: Tools from all incarnations are registered and available, even if that incarnation isn't active\n4. **Easy extension**: Create new incarnations with the provided template\n\n#### Creating a New Incarnation\n\nTo create a new incarnation:\n\n1. Create a new file in the `src/mcp_neocoder/incarnations/` directory with the naming pattern `your_incarnation_name_incarnation.py`\n2. Use this template structure:\n\n```python\n\"\"\"\nYour incarnation name and description\n\"\"\"\n\nimport json\nimport logging\nimport uuid\nfrom typing import Dict, Any, List, Optional, Union\n\nimport mcp.types as types\nfrom pydantic import Field\nfrom neo4j import AsyncTransaction\n\nfrom .polymorphic_adapter import BaseIncarnation, IncarnationType\n\nlogger = logging.getLogger(\"mcp_neocoder.incarnations.your_incarnation_name\")\n\n\nclass YourIncarnationNameIncarnation(BaseIncarnation):\n    \"\"\"\n    Your detailed incarnation description here\n    \"\"\"\n\n    # Define the incarnation type - must match an entry in IncarnationType enum\n    incarnation_type = IncarnationType.YOUR_INCARNATION_TYPE\n\n    # Metadata for display in the UI\n    description = \"Your incarnation short description\"\n    version = \"0.1.0\"\n\n    # Initialize schema and add tools here\n    async def initialize_schema(self):\n        \"\"\"Initialize the schema for your incarnation.\"\"\"\n        # Implementation...\n\n    # Add more tool methods below\n    async def your_tool_name(self, param1: str, param2: Optional[int] = None) -> List[types.TextContent]:\n        \"\"\"Tool description.\"\"\"\n        # Implementation...\n```\n\n3. Add your incarnation type to the `IncarnationType` enum in `polymorphic_adapter.py`\n4. Restart the server, and your new incarnation will be automatically discovered\n\nSee [incarnations.md](./docs/incarnations.md) for detailed documentation on using and creating incarnations.\n\n## Available Templates\n\nNeoCoder comes with these standard templates:\n\n1. **FIX** - Guidance on fixing a reported bug, including mandatory testing and logging\n2. **REFACTOR** - Structured approach to refactoring code while maintaining functionality\n3. **DEPLOY** - Guidance on deploying code to production environments with safety checks\n4. **FEATURE** - Structured approach to implementing new features with proper testing and documentation\n5. **TOOL_ADD** - Process for adding new tool functionality to the NeoCoder MCP server\n6. **CYPHER_SNIPPETS** - Manage and use Cypher snippets for Neo4j queries\n7. **CODE_ANALYZE** - Structured workflow for analyzing code using AST and ASG tools\n\n## Architecture\n\n### Knowledge Graph Structure\n\n- **:AiGuidanceHub**: Central navigation hub for the AI\n- **:ActionTemplate**: Templates for standard workflows (FIX, REFACTOR, etc.)\n- **:Project**: Project data including README and structure\n- **:File/Directory**: Project file structure representation\n- **:WorkflowExecution**: Audit trail of completed workflows\n- **:BestPracticesGuide**: Coding standards and guidelines\n- **:TemplatingGuide**: How to create/modify templates\n- **:SystemUsageGuide**: How to use the graph system\n\n### MCP Server Tools\n\nThe MCP server provides the following tools to AI assistants:\n\n#### Core Tools\n- **check_connection**: Verify Neo4j connection status\n- **get_guidance_hub**: Entry point for AI navigation\n- **get_action_template**: Get a specific workflow template\n- **list_action_templates**: See all available templates\n- **get_best_practices**: View coding standards\n- **get_project**: View project details including README\n- **list_projects**: List all projects in the system\n- **log_workflow_execution**: Record a successful workflow completion\n- **get_workflow_history**: View audit trail of work done\n- **add_template_feedback**: Provide feedback on templates\n- **run_custom_query**: Run direct Cypher queries\n- **write_neo4j_cypher**: Execute write operations on the graph\n\n#### Incarnation Management Tools\n- **get_current_incarnation**: Get the currently active incarnation\n- **list_incarnations**: List all available incarnations\n- **switch_incarnation**: Switch to a different incarnation\n- **suggest_tool**: Get tool suggestions based on task description\n\nEach incarnation provides additional specialized tools that are automatically registered when the incarnation is activated.\n\n#### Knowledge Graph Tools\n\nThe Knowledge Graph incarnation provides these specialized tools for managing and analyzing knowledge structures:\n\n- **create_entities**: Create multiple new entities with observations\n  - Each entity has a name, type, and a list of observations\n  - All entities are properly labeled for efficient querying\n\n- **create_relations**: Connect entities with typed relationships\n  - Relations are created with proper typing and timestamps\n  - Relations must specify from entity, to entity, and relation type\n\n- **add_observations**: Add new observations to existing entities\n  - Add multiple observations to one or more entities\n  - Observations are timestamped for temporal tracking\n\n- **delete_entities**: Remove entities and their associated data\n  - Deletes the entity, its observations, and connected relationships\n  - Provides cascading deletion for clean graph management\n\n- **delete_observations**: Remove specific observations from entities\n  - Targeted deletion of specific observation content\n  - Preserves entity and relationship structure\n\n- **delete_relations**: Remove relationships between entities\n  - Specify exact relationships to remove by type and connected entities\n  - Maintains entity and observation data\n\n- **read_graph**: View the entire knowledge graph structure\n  - Returns entities, their observations, and relationships\n  - Formatted for easy reading and analysis\n\n- **search_nodes**: Find entities by name, type, or observation content\n  - Full-text search capabilities with relevance ranking\n  - Highlights matching terms in search results\n\n- **open_nodes**: Get detailed information about specific entities\n  - Shows all observations, incoming and outgoing relationships\n  - Provides complete contextual view of selected entities\n\nThese tools provide a comprehensive knowledge graph management system that efficiently leverages Neo4j's graph capabilities.\n\n#### Cypher Snippet Toolkit\n\nThe MCP server includes a toolkit for managing and searching Cypher query snippets:\n\n- **list_cypher_snippets**: List all available Cypher snippets with optional filtering\n- **get_cypher_snippet**: Get a specific Cypher snippet by ID\n- **search_cypher_snippets**: Search for Cypher snippets by keyword, tag, or pattern\n- **create_cypher_snippet**: Add a new Cypher snippet to the database\n- **update_cypher_snippet**: Update an existing Cypher snippet\n- **delete_cypher_snippet**: Delete a Cypher snippet from the database\n- **get_cypher_tags**: Get all tags used for Cypher snippets\n\nThis toolkit provides a searchable repository of Cypher query patterns and examples that can be used as a reference and learning tool.\n\n#### Tool Proposal System\n\nThe MCP server includes a system for proposing and requesting new tools:\n\n- **propose_tool**: Propose a new tool for the NeoCoder system\n- **request_tool**: Request a new tool feature as a user\n- **get_tool_proposal**: Get details of a specific tool proposal\n- **get_tool_request**: Get details of a specific tool request\n- **list_tool_proposals**: List all tool proposals with optional filtering\n- **list_tool_requests**: List all tool requests with optional filtering\n\nThis system allows AI assistants to suggest new tools and users to request new functionality, providing a structured way to manage and track feature requests.\n\n![alt text](image-2.png)\n\n## Customizing Templates\n\nTemplates are stored in the `templates` directory as `.cypher` files. You can edit existing templates or create new ones.\n\nTo add a new template:\n\n1. Create a new file in the `templates` directory (e.g., `custom_template.cypher`)\n2. Follow the format of existing templates\n3. Initialize the database to load the template into Neo4j\n\n## The 'Cypher Snippet Toolkit' tools operate on the graph structure defined below\n\nBelow is a consolidated, **Neo4j 5-seriesâ€“ready** toolkit you can paste straight into Neo4j Browser, Cypher shell, or any driver.\nIt creates a *mini-documentation graph* where every **`(:CypherSnippet)`** node stores a piece of Cypher syntax, an example, and metadata; text and (optionally) vector indexes make the snippets instantly searchable from plain keywords *or* embeddings.\n\n---\n\n## 1 Â· Schema & safety constraints\n\n```cypher\n// 1-A Uniqueness for internal IDs\nCREATE CONSTRAINT cypher_snippet_id IF NOT EXISTS\nFOR   (c:CypherSnippet)\nREQUIRE c.id IS UNIQUE;            // Neo4j 5 syntax\n\n// 1-B Optional tag helper (one Tag node per word/phrase)\nCREATE CONSTRAINT tag_name_unique IF NOT EXISTS\nFOR   (t:Tag)\nREQUIRE t.name IS UNIQUE;\n```\n\n## 2 Â· Indexes that power search\n\n```cypher\n// 2-A Quick label/property look-ups\nCREATE LOOKUP INDEX snippetLabelLookup IF NOT EXISTS\nFOR (n) ON EACH labels(n);\n\n// 2-B Plain-text index (fast prefix / CONTAINS / = queries)\nCREATE TEXT INDEX snippet_text_syntax IF NOT EXISTS\nFOR (c:CypherSnippet) ON (c.syntax);\n\nCREATE TEXT INDEX snippet_text_description IF NOT EXISTS\nFOR (c:CypherSnippet) ON (c.description);\n\n// 2-C Full-text scoring index (tokenised, ranked search)\nCREATE FULLTEXT INDEX snippet_fulltext IF NOT EXISTS\nFOR (c:CypherSnippet) ON EACH [c.syntax, c.example];\n\n// 2-D (OPTIONAL) Vector index for embeddings â‰¥Neo4j 5.15\nCREATE VECTOR INDEX snippet_vec IF NOT EXISTS\nFOR (c:CypherSnippet) ON (c.embedding)\nOPTIONS {indexConfig: {\n  `vector.dimensions`: 384,\n  `vector.similarity_function`: 'cosine'\n}};\n```\n\n*If your build is â‰¤5.14, call `db.index.vector.createNodeIndex` instead.*\n\n## 3 Â· Template to store a snippet\n\n```cypher\n:params {\n  snippet: {\n    id:         'create-node-basic',\n    name:       'CREATE node (basic)',\n    syntax:     'CREATE (n:Label {prop: $value})',\n    description:'Creates a single node with one label and properties.',\n    example:    'CREATE (p:Person {name:$name, age:$age})',\n    since:      5.0,\n    tags:       ['create','insert','node']\n  }\n}\n\n// 3-A MERGE guarantees idempotence\nMERGE (c:CypherSnippet {id:$snippet.id})\nSET   c += $snippet\nWITH  c, $snippet.tags AS tags\nUNWIND tags AS tag\n  MERGE (t:Tag {name:tag})\n  MERGE (c)-[:TAGGED_AS]->(t);\n```\n\nParameter maps keep code reusable and prevent query-plan recompilation.\n\n## 4 Â· How to search\n\n### 4-A Exact / prefix match via TEXT index\n\n```cypher\nMATCH (c:CypherSnippet)\nWHERE c.name STARTS WITH $term      // fast TEXT index hit\nRETURN c.name, c.syntax, c.example\nORDER BY c.name;\n```\n\n### 4-B Ranked full-text search\n\n```cypher\nCALL db.index.fulltext.queryNodes(\n  'snippet_fulltext',               // index name\n  $q                                // raw search string\n) YIELD node, score\nRETURN node.name, node.syntax, score\nORDER BY score DESC\nLIMIT 10;\n```\n\n### 4-C Embedding similarity (vector search)\n\n```cypher\nWITH $queryEmbedding AS vec\nCALL db.index.vector.queryNodes(\n  'snippet_vec', 5, vec            // top-5 cosine hits\n) YIELD node, similarity\nRETURN node.name, node.syntax, similarity\nORDER BY similarity DESC;\n```\n\n## 5 Â· Updating or deleting snippets\n\n```cypher\n// 5-A Edit description\nMATCH (c:CypherSnippet {id:$id})\nSET   c.description = $newText,\n      c.lastUpdated = date()\nRETURN c;\n\n// 5-B Remove a snippet cleanly\nMATCH (c:CypherSnippet {id:$id})\nDETACH DELETE c;\n```\n\nBoth operations automatically maintain index consistency â€“ no extra work required.\n\n## 6 Â· Bulk export / import (APOC)\n\n```cypher\nCALL apoc.export.cypher.all(\n  'cypher_snippets.cypher',\n  {useOptimizations:true, format:'cypher-shell'}\n);\n```\n\nThis writes share-ready Cypher that can be replayed with `cypher-shell < cypher_snippets.cypher`.\n\n---\n\n### Quick-start recap\n\n1. **Run Section 1 & 2** once per database to set up constraints and indexes.\n2. Use **Section 3** (param-driven) to add new documentation entries.\n3. Query with **Section 4**, and optionally add vector search if you store embeddings.\n4. Backup or publish with **Section 6**.\n\nWith these building blocks you now have a *living*, searchable \"Cypher cheat-sheet inside Cypher\" that always stays local, versionable, and extensible. Enjoy friction-free recall as your query repertoire grows!\n\n*Note: A full reference version of this documentation that preserves all original formatting is available in the `/docs/cypher_snippets_reference.md` file.*\n\nCreated by [angrysky56](https://github.com/angrysky56)\nClaude 3.7 Sonnet\nGemini 2.5 Pro Preview 3-25\nChatGPT o3\n\n## Code Analysis\n\nA comprehensive analysis of the NeoCoder codebase is available in the `/analysis` directory. This includes:\n\n- Architecture overview\n- Incarnation system analysis\n- Code metrics and structure\n- Workflow template analysis\n- Integration points\n- Recommendations for future development\n\n## Recent Updates\n\n### 2025-06-14: Fixed Critical Async/Event Loop Management Issues (v1.4.1)\n- **CRITICAL FIX**: Resolved async context manager protocol errors in `safe_neo4j_session` function\n- **Root Cause**: AsyncMock in tests and some driver configurations returned coroutines instead of async context managers\n- **Solution**: Added `_handle_session_creation` helper function to detect and properly handle both coroutines and context managers\n- **Impact**: Eliminates \"TypeError: 'coroutine' object does not support the asynchronous context manager protocol\" errors\n- **Testing**: Added comprehensive test suite (`test_event_loop_fix.py`) to prevent regression\n- **Compatibility**: Maintains full backward compatibility with existing Neo4j driver usage\n- **Files Modified**: `src/mcp_neocoder/event_loop_manager.py`, `tests/test_event_loop_fix.py`\n\n### 2025-04-27: Added Code Analysis Incarnation with AST/ASG Support (v1.4.0)\n- Added new `code_analysis_incarnation.py` for deep code analysis using AST and ASG tools\n- Implemented Neo4j schema for storing code structure and analysis results\n- Added CODE_ANALYZE action template with step-by-step workflow\n- Created specialized tools for code analysis:\n  - `analyze_codebase`: Analyze entire directory structures\n  - `analyze_file`: Deep analysis of individual files\n  - `compare_versions`: Compare different versions of code\n  - `find_code_smells`: Identify potential code issues\n  - `generate_documentation`: Auto-generate code documentation\n  - `explore_code_structure`: Navigate code structure\n  - `search_code_constructs`: Find specific patterns in code\n- Integrated with external AST/ASG tools\n- Added proper documentation in guidance hub\n- Updated IncarnationType enum to include CODE_ANALYSIS type\n\n### 2025-04-27: Eliminated Knowledge Graph Transaction Error Messages (v1.3.2)\n- Completely eliminated error messages related to transaction scope issues in knowledge graph functions\n- Implemented server-side error message interception and replacement for a smoother user experience\n- Added a new safer execution pattern for all database operations:\n  - Created `_safe_execute_write` method to eliminate transaction scope errors in write operations\n  - Created `_safe_read_query` method to ensure proper transaction handling for read operations\n  - Improved entity count tracking for accurate operation feedback\n- Enhanced error recovery to continue operations even when JSON parsing fails\n- Simplified and improved all knowledge graph tool implementations\n- Maintained full backward compatibility with existing knowledge graph data\n- Enhanced guidance hub with clearer usage examples\n\n### 2025-04-27: Fixed Knowledge Graph Transaction Scope Issues (v1.3.1)\n- Fixed critical issue with knowledge graph functions returning \"transaction out of scope\" errors\n- Implemented a transaction-safe approach for all knowledge graph operations\n- Updated all knowledge graph tools to properly handle transaction contexts:\n  - Fixed `create_entities` to properly return results\n  - Fixed `create_relations` with a simplified approach\n  - Fixed `add_observations` to ensure data is committed\n  - Fixed `delete_entities`, `delete_observations`, and `delete_relations` functions\n  - Fixed `read_graph` to fetch data in multiple safe transactions\n  - Fixed `search_nodes` with a more robust query approach\n  - Fixed `open_nodes` to query entity details safely\n- Enhanced guidance hub with clear examples of knowledge graph tool usage\n- Improved error handling throughout knowledge graph operations\n- Maintained backward compatibility with existing knowledge graph data\n\n### 2025-04-26: Fixed Knowledge Graph API Functions (v1.3.0)\n- Fixed the issue with Knowledge Graph API functions not properly integrating with Neo4j node labeling system\n- Implemented properly labeled entities with :Entity label instead of generic :KnowledgeNode\n- Added full set of knowledge graph management functions:\n  - `create_entities`: Create entities with proper labeling and observations\n  - `create_relations`: Connect entities with typed relationships\n  - `add_observations`: Add observations to existing entities\n  - `delete_entities`: Remove entities and their connections\n  - `delete_observations`: Remove specific observations from entities\n  - `delete_relations`: Remove relationships between entities\n  - `read_graph`: View the entire knowledge graph structure\n  - `search_nodes`: Find entities by name, type, or observation content\n  - `open_nodes`: Get detailed information about specific entities\n- Added fulltext search support with fallback for non-fulltext environments\n- Added proper schema initialization with constraints and indexes for knowledge graph\n- Updated guidance hub content with usage instructions for the new API functions\n\n### 2025-04-25: Expanded Incarnation Documentation (v1.2.0)\n- Added detailed documentation on the architectural principles behind multiple incarnations\n- Enhanced description of each incarnation type with operational patterns and use cases\n- Added information about common graph schema motifs across incarnations\n- Included implementation roadmap for integrating quantum-inspired approaches\n\n### 2025-04-24: Fixed Incarnation Tool Registration (v1.1.0)\n- Fixed the issue where incarnation tools weren't being properly registered on server startup\n- Fixed circular dependency issues with duplicate class definitions\n- Added explicit tool method declaration support via `_tool_methods` class attribute\n- Improved the tool discovery mechanism to ensure all tools from each incarnation are properly detected\n- Enhanced event loop handling to prevent issues during server initialization\n- Added comprehensive logging to aid in troubleshooting\n- Fixed schema initialization to properly defer until needed\n\nSee the [CHANGELOG.md](./CHANGELOG.md) file for detailed implementation notes.\n\n## License\n\nMIT License\n"
}