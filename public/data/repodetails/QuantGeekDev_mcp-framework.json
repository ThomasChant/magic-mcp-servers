{
  "mcp_name": "mcp-framework",
  "mcp_description": "Fast and elegant Typescript framework for building MCP servers",
  "mcp_id": "QuantGeekDev_mcp-framework",
  "fetch_timestamp": "2025-06-23T06:34:37.801032Z",
  "github_url": "https://github.com/QuantGeekDev/mcp-framework",
  "repository": {
    "name": "mcp-framework",
    "full_name": "QuantGeekDev/mcp-framework",
    "description": "A framework for writing MCP (Model Context Protocol) servers in Typescript",
    "html_url": "https://github.com/QuantGeekDev/mcp-framework",
    "created_at": "2024-12-08T22:37:28Z",
    "updated_at": "2025-06-22T19:33:37Z",
    "pushed_at": "2025-06-18T15:00:16Z",
    "size": 360,
    "stargazers_count": 737,
    "watchers_count": 737,
    "forks_count": 74,
    "open_issues_count": 29,
    "language": "TypeScript",
    "license": "MIT License",
    "topics": [
      "anthropic",
      "claude",
      "genai",
      "llm",
      "llms",
      "mcp",
      "modelcontextprotocol"
    ],
    "default_branch": "main",
    "owner": {
      "login": "QuantGeekDev",
      "type": "User",
      "avatar_url": "https://avatars.githubusercontent.com/u/58406316?v=4",
      "html_url": "https://github.com/QuantGeekDev"
    },
    "has_issues": true,
    "has_projects": true,
    "has_downloads": true,
    "has_wiki": true,
    "has_pages": false,
    "archived": false,
    "disabled": false,
    "visibility": "public",
    "network_count": 74,
    "subscribers_count": 15,
    "languages": {
      "TypeScript": 171877,
      "JavaScript": 7487
    },
    "language_percentages": {
      "TypeScript": 95.83,
      "JavaScript": 4.17
    },
    "pull_requests_count": 81,
    "contributors_count": 10,
    "latest_release": {
      "tag_name": "mcp-framework-v0.2.15",
      "name": "mcp-framework: v0.2.15",
      "published_at": "2025-06-18T15:00:16Z",
      "body": "## [0.2.15](https://github.com/QuantGeekDev/mcp-framework/compare/mcp-framework-v0.2.14...mcp-framework-v0.2.15) (2025-06-18)\n\n\n### Bug Fixes\n\n* http transport uses same tool loading ([0d0a8d8](https://github.com/QuantGeekDev/mcp-framework/commit/0d0a8d898b03acc722d88683eee9895bfbe5b518))\n* http transport uses same tool loading ([7ff3c11](https://github.com/QuantGeekDev/mcp-framework/commit/7ff3c115506394b2589a7bac2fa81e9401682f7b))",
      "prerelease": false,
      "draft": false
    },
    "tags": [
      {
        "name": "mcp-framework-v0.2.15",
        "commit_sha": "0827becb8b77805baa2f0a7577deaaaaabc9cdcf"
      },
      {
        "name": "mcp-framework-v0.2.14",
        "commit_sha": "dbb679b3886d56a1437f141ce58c9dc133e2c59f"
      },
      {
        "name": "mcp-framework-v0.2.13",
        "commit_sha": "4628335b9390ee1c7e5299412b73534d5456ac6a"
      },
      {
        "name": "mcp-framework-v0.2.12",
        "commit_sha": "1cba1c01ce69aec04bcd1afca9031f169ccea749"
      },
      {
        "name": "mcp-framework-v0.2.11",
        "commit_sha": "b6de268711cbfed71da08c949c67be90db05b4d5"
      },
      {
        "name": "mcp-framework-v0.2.10",
        "commit_sha": "cc0cb66b4f8b8006f3bcf25fb5dda209c48df949"
      },
      {
        "name": "mcp-framework-v0.2.9",
        "commit_sha": "c5e5b3791a64c0c091731e532438bc626e286751"
      },
      {
        "name": "mcp-framework-v0.2.8",
        "commit_sha": "02cadc33fcee607abd7db13998023e55c2fee89c"
      }
    ],
    "latest_version": "mcp-framework-v0.2.15",
    "package_json_version": "0.2.15"
  },
  "readme": "# MCP Framework\n\nMCP-Framework is a framework for building Model Context Protocol (MCP) servers elegantly in TypeScript.\n\nMCP-Framework gives you architecture out of the box, with automatic directory-based discovery for tools, resources, and prompts. Use our powerful MCP abstractions to define tools, resources, or prompts in an elegant way. Our cli makes getting started with your own MCP server a breeze\n\n## Features\n\n- üõ†Ô∏è Automatic discovery and loading of tools, resources, and prompts\n- Multiple transport support (stdio, SSE, HTTP Stream)\n- TypeScript-first development with full type safety\n- Built on the official MCP SDK\n- Easy-to-use base classes for tools, prompts, and resources\n- Out of the box authentication for SSE endpoints\n\n## Projects Built with MCP Framework\n\nThe following projects and services are built using MCP Framework:\n\n- ### [tip.md](https://tip.md)\nA crypto tipping service that enables AI assistants to help users send cryptocurrency tips to content creators directly from their chat interface. The MCP service allows for:\n - Checking wallet types for users\n - Preparing cryptocurrency tips for users/agents to complete\nSetup instructions for various clients (Cursor, Sage, Claude Desktop) are available in their [MCP Server documentation](https://docs.tip.md/mcp-server/).\n\n## Support our work\n\n[![Tip in Crypto](https://tip.md/badge.svg)](https://tip.md/QuantGeekDev)\n\n\n# [Read the full docs here](https://mcp-framework.com)\n\n\n\n\n\n## Creating a repository with mcp-framework\n\n### Using the CLI (Recommended)\n\n```bash\n# Install the framework globally\nnpm install -g mcp-framework\n\n# Create a new MCP server project\nmcp create my-mcp-server\n\n# Navigate to your project\ncd my-mcp-server\n\n# Your server is ready to use!\n```\n\n## CLI Usage\n\nThe framework provides a powerful CLI for managing your MCP server projects:\n\n### Project Creation\n\n```bash\n# Create a new project\nmcp create <your project name here>\n\n# Create a new project with the new EXPERIMENTAL HTTP transport\nHeads up: This will set cors allowed origin to \"*\", modify it in the index if you wish\nmcp create <your project name here> --http --port 1337 --cors\n```\n\n# Options:\n# --http: Use HTTP transport instead of default stdio\n# --port <number>: Specify HTTP port (default: 8080)\n# --cors: Enable CORS with wildcard (*) access\n\n### Adding a Tool\n\n```bash\n# Add a new tool\nmcp add tool price-fetcher\n```\n\n### Building and Validation\n\nThe framework provides comprehensive validation to ensure your tools are properly documented and functional:\n\n```bash\n# Build with automatic validation (recommended)\nnpm run build\n\n# Build with custom validation settings\nMCP_SKIP_TOOL_VALIDATION=false npm run build  # Force validation (default)\nMCP_SKIP_TOOL_VALIDATION=true npm run build   # Skip validation (not recommended)\n```\n\n### Validating Tools\n\n```bash\n# Validate all tools have proper descriptions (for Zod schemas)\nmcp validate\n```\n\nThis command checks that all tools using Zod schemas have descriptions for every field. The validation runs automatically during build, but you can also run it standalone:\n\n- ‚úÖ **During build**: `npm run build` automatically validates tools\n- ‚úÖ **Standalone**: `mcp validate` for manual validation\n- ‚úÖ **Development**: Use `defineSchema()` helper for immediate feedback\n- ‚úÖ **Runtime**: Server validates tools on startup\n\n**Example validation error:**\n```bash\n‚ùå Tool validation failed:\n  ‚ùå PriceFetcher.js: Missing descriptions for fields in price_fetcher: symbol, currency. \nAll fields must have descriptions when using Zod object schemas. \nUse .describe() on each field, e.g., z.string().describe(\"Field description\")\n```\n\n**Integrating validation into CI/CD:**\n```json\n{\n  \"scripts\": {\n    \"build\": \"tsc && mcp-build\",\n    \"test\": \"jest && mcp validate\",\n    \"prepack\": \"npm run build && mcp validate\"\n  }\n}\n```\n\n### Adding a Prompt\n\n```bash\n# Add a new prompt\nmcp add prompt price-analysis\n```\n\n### Adding a Resource\n\n```bash\n# Add a new prompt\nmcp add resource market-data\n```\n\n## Development Workflow\n\n1. **Create your project:**\n   ```bash\n   mcp create my-mcp-server\n   cd my-mcp-server\n   ```\n\n2. **Add tools:**\n   ```bash\n   mcp add tool data-fetcher\n   mcp add tool data-processor\n   mcp add tool report-generator\n   ```\n\n3. **Define your tool schemas with automatic validation:**\n   ```typescript\n   // tools/DataFetcher.ts\n   import { MCPTool, MCPInput as AddToolInput } from \"mcp-framework\";\n  import { z } from \"zod\";\n\n  const AddToolSchema = z.object({\n  a: z.number().describe(\"First number to add\"),\n  b: z.number().describe(\"Second number to add\"),\n  });\n\n  class AddTool extends MCPTool {\n  name = \"add\";\n  description = \"Add tool description\";\n  schema = AddToolSchema;\n\n  async execute(input: AddToolInput<this>) {\n    const result = input.a + input.b;\n    return `Result: ${result}`;\n    }\n  }\n  export default AddTool;\n\n   ```\n\n4. **Build with automatic validation:**\n   ```bash\n   npm run build  # Automatically validates schemas and compiles\n   ```\n\n5. **Optional: Run standalone validation:**\n   ```bash\n   mcp validate  # Check all tools independently\n   ```\n\n6. **Test your server:**\n   ```bash\n   node dist/index.js  # Server validates tools on startup\n   ```\n\n7. **Add to MCP Client** (see Claude Desktop example below)\n\n**Pro Tips:**\n- Use `defineSchema()` during development for immediate feedback\n- Build process automatically catches missing descriptions\n- Server startup validates all tools before accepting connections\n- Use TypeScript's autocomplete with `McpInput<this>` for better DX\n\n## Using with Claude Desktop\n\n### Local Development\n\nAdd this configuration to your Claude Desktop config file:\n\n**MacOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`\n**Windows**: `%APPDATA%/Claude/claude_desktop_config.json`\n\n```json\n{\n\"mcpServers\": {\n\"${projectName}\": {\n      \"command\": \"node\",\n      \"args\":[\"/absolute/path/to/${projectName}/dist/index.js\"]\n}\n}\n}\n```\n\n### After Publishing\n\nAdd this configuration to your Claude Desktop config file:\n\n**MacOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`\n**Windows**: `%APPDATA%/Claude/claude_desktop_config.json`\n\n```json\n{\n\"mcpServers\": {\n\"${projectName}\": {\n      \"command\": \"npx\",\n      \"args\": [\"${projectName}\"]\n}\n}\n}\n```\n\n## Building and Testing\n\n1. Make changes to your tools\n2. Run `npm run build` to compile\n3. The server will automatically load your tools on startup\n\n## Environment Variables\n\nThe framework supports the following environment variables for configuration:\n\n| Variable              | Description                                           | Default     |\n|-----------------------|-------------------------------------------------------|-------------|\n| MCP_ENABLE_FILE_LOGGING | Enable logging to files (true/false)                 | false       |\n| MCP_LOG_DIRECTORY     | Directory where log files will be stored             | logs        |\n| MCP_DEBUG_CONSOLE     | Display debug level messages in console (true/false) | false       |\n\nExample usage:\n\n```bash\n# Enable file logging\nMCP_ENABLE_FILE_LOGGING=true node dist/index.js\n\n# Specify a custom log directory\nMCP_ENABLE_FILE_LOGGING=true MCP_LOG_DIRECTORY=my-logs node dist/index.js\n\n# Enable debug messages in console\nMCP_DEBUG_CONSOLE=true node dist/index.js\n```\n\n## Quick Start\n\n### Defining Tools\n\nMCP Framework uses Zod schemas for defining tool inputs, providing type safety, validation, and automatic documentation:\n\n```typescript\nimport { MCPTool, McpInput } from \"mcp-framework\";\nimport { z } from \"zod\";\n\nconst AddToolSchema = z.object({\n  a: z.number().describe(\"First number to add\"),\n  b: z.number().describe(\"Second number to add\"),\n});\n\nclass AddTool extends MCPTool {\n  name = \"add\";\n  description = \"Add tool description\";\n  schema = AddToolSchema;\n\n  async execute(input: McpInput<this>) {\n    const result = input.a + input.b;\n    return `Result: ${result}`;\n  }\n}\n\nexport default AddTool;\n```\n\n**Key Benefits:**\n- ‚úÖ **Single source of truth** - Define types and validation in one place\n- ‚úÖ **Automatic type inference** - TypeScript types are inferred from your schema\n- ‚úÖ **Rich validation** - Leverage Zod's powerful validation features\n- ‚úÖ **Required descriptions** - Framework enforces documentation\n- ‚úÖ **Better IDE support** - Full autocomplete and type checking\n- ‚úÖ **Cleaner code** - No duplicate type definitions\n\n### Advanced Zod Schema Features\n\nThe framework supports all Zod features:\n\n```typescript\nimport { MCPTool, McpInput } from \"mcp-framework\";\nimport { z } from \"zod\";\n\nconst AdvancedSchema = z.object({\n  // String constraints and formats\n  email: z.string().email().describe(\"User email address\"),\n  name: z.string().min(2).max(50).describe(\"User name\"),\n  website: z.string().url().optional().describe(\"Optional website URL\"),\n  \n  // Number constraints\n  age: z.number().int().positive().max(120).describe(\"User age\"),\n  rating: z.number().min(1).max(5).describe(\"Rating from 1 to 5\"),\n  \n  // Arrays and objects\n  tags: z.array(z.string()).describe(\"List of tags\"),\n  metadata: z.object({\n    priority: z.enum(['low', 'medium', 'high']).describe(\"Task priority\"),\n    dueDate: z.string().optional().describe(\"Due date in ISO format\")\n  }).describe(\"Additional metadata\"),\n  \n  // Default values\n  status: z.string().default('pending').describe(\"Current status\"),\n  \n  // Unions and enums\n  category: z.union([\n    z.literal('personal'),\n    z.literal('work'),\n    z.literal('other')\n  ]).describe(\"Category type\")\n});\n\nclass AdvancedTool extends MCPTool {\n  name = \"advanced_tool\";\n  description = \"Tool demonstrating advanced Zod features\";\n  schema = AdvancedSchema;\n\n  async execute(input: McpInput<this>) {\n    // TypeScript automatically knows all the types!\n    const { email, name, website, age, rating, tags, metadata, status, category } = input;\n    \n    console.log(input.name.toUpperCase()); // ‚úÖ TypeScript knows this is valid\n    console.log(input.age.toFixed(2));     // ‚úÖ Number methods available\n    console.log(input.tags.length);       // ‚úÖ Array methods available\n    console.log(input.website?.includes(\"https\")); // ‚úÖ Optional handling\n    \n    return `Processed user: ${name}`;\n  }\n}\n```\n\n### Automatic Type Inference\n\nThe `McpInput<this>` type automatically infers the correct input type from your schema, eliminating the need for manual type definitions:\n\n```typescript\nclass MyTool extends MCPTool {\n  schema = z.object({\n    name: z.string().describe(\"User name\"),\n    age: z.number().optional().describe(\"User age\"),\n    tags: z.array(z.string()).describe(\"User tags\")\n  });\n\n  async execute(input: McpInput<this>) {\n    // TypeScript automatically knows:\n    // input.name is string\n    // input.age is number | undefined  \n    // input.tags is string[]\n    \n    console.log(input.name.toUpperCase()); // ‚úÖ TypeScript knows this is valid\n    console.log(input.age?.toFixed(2));    // ‚úÖ Handles optional correctly\n    console.log(input.tags.length);       // ‚úÖ Array methods available\n  }\n}\n```\n\nNo more duplicate interfaces or generic type parameters needed!\n\n### Schema Validation & Descriptions\n\n**All schema fields must have descriptions**. This ensures your tools are well-documented and provides better user experience in MCP clients.\n\nThe framework validates descriptions at multiple levels:\n\n#### 1. Build-time Validation (Recommended)\n```bash\nnpm run build  # Automatically validates during compilation\n```\n\n#### 2. Development-time Validation\nUse the `defineSchema` helper for immediate feedback:\n\n```typescript\nimport { defineSchema } from \"mcp-framework\";\n\n// This will throw an error immediately if descriptions are missing\nconst MySchema = defineSchema({\n  name: z.string(),  // ‚ùå Error: Missing description\n  age: z.number().describe(\"User age\")  // ‚úÖ Good\n});\n```\n\n#### 3. Standalone Validation\n```bash\nmcp validate  # Check all tools for proper descriptions\n```\n\n#### 4. Runtime Validation\nThe server automatically validates tools on startup.\n\n**To skip validation** (not recommended):\n```bash\n# Skip during build\nMCP_SKIP_TOOL_VALIDATION=true npm run build\n\n# Skip during development\nNODE_ENV=production npm run dev\n```\n\n### Setting up the Server\n\n```typescript\nimport { MCPServer } from \"mcp-framework\";\n\nconst server = new MCPServer();\n\n// OR (mutually exclusive!) with SSE transport\nconst server = new MCPServer({\n  transport: {\n    type: \"sse\",\n    options: {\n      port: 8080            // Optional (default: 8080)\n    }\n  }\n});\n\n// Start the server\nawait server.start();\n```\n\n## Transport Configuration\n\n### stdio Transport (Default)\n\nThe stdio transport is used by default if no transport configuration is provided:\n\n```typescript\nconst server = new MCPServer();\n// or explicitly:\nconst server = new MCPServer({\n  transport: { type: \"stdio\" }\n});\n```\n\n### SSE Transport\n\nTo use Server-Sent Events (SSE) transport:\n\n```typescript\nconst server = new MCPServer({\n  transport: {\n    type: \"sse\",\n    options: {\n      port: 8080,            // Optional (default: 8080)\n      endpoint: \"/sse\",      // Optional (default: \"/sse\")\n      messageEndpoint: \"/messages\", // Optional (default: \"/messages\")\n      cors: {\n        allowOrigin: \"*\",    // Optional (default: \"*\")\n        allowMethods: \"GET, POST, OPTIONS\", // Optional (default: \"GET, POST, OPTIONS\")\n        allowHeaders: \"Content-Type, Authorization, x-api-key\", // Optional (default: \"Content-Type, Authorization, x-api-key\")\n        exposeHeaders: \"Content-Type, Authorization, x-api-key\", // Optional (default: \"Content-Type, Authorization, x-api-key\")\n        maxAge: \"86400\"      // Optional (default: \"86400\")\n      }\n    }\n  }\n});\n```\n\n### HTTP Stream Transport\n\nTo use HTTP Stream transport:\n\n```typescript\nconst server = new MCPServer({\n  transport: {\n    type: \"http-stream\",\n    options: {\n      port: 8080,                // Optional (default: 8080)\n      endpoint: \"/mcp\",          // Optional (default: \"/mcp\") \n      responseMode: \"batch\",     // Optional (default: \"batch\"), can be \"batch\" or \"stream\"\n      batchTimeout: 30000,       // Optional (default: 30000ms) - timeout for batch responses\n      maxMessageSize: \"4mb\",     // Optional (default: \"4mb\") - maximum message size\n      \n      // Session configuration\n      session: {\n        enabled: true,           // Optional (default: true)\n        headerName: \"Mcp-Session-Id\", // Optional (default: \"Mcp-Session-Id\")\n        allowClientTermination: true, // Optional (default: true)\n      },\n      \n      // Stream resumability (for missed messages)\n      resumability: {\n        enabled: false,          // Optional (default: false)\n        historyDuration: 300000, // Optional (default: 300000ms = 5min) - how long to keep message history\n      },\n      \n      // CORS configuration\n      cors: {\n        allowOrigin: \"*\"         // Other CORS options use defaults\n      }\n    }\n  }\n});\n```\n\n#### Response Modes\n\nThe HTTP Stream transport supports two response modes:\n\n1. **Batch Mode** (Default): Responses are collected and sent as a single JSON-RPC response. This is suitable for typical request-response patterns and is more efficient for most use cases.\n\n2. **Stream Mode**: All responses are sent over a persistent SSE connection opened for each request. This is ideal for long-running operations or when the server needs to send multiple messages in response to a single request.\n\nYou can configure the response mode based on your specific needs:\n\n```typescript\n// For batch mode (default):\nconst server = new MCPServer({\n  transport: {\n    type: \"http-stream\",\n    options: {\n      responseMode: \"batch\"\n    }\n  }\n});\n\n// For stream mode:\nconst server = new MCPServer({\n  transport: {\n    type: \"http-stream\",\n    options: {\n      responseMode: \"stream\"\n    }\n  }\n});\n```\n\n#### HTTP Stream Transport Features\n\n- **Session Management**: Automatic session tracking and management\n- **Stream Resumability**: Optional support for resuming streams after connection loss\n- **Batch Processing**: Support for JSON-RPC batch requests/responses\n- **Comprehensive Error Handling**: Detailed error responses with JSON-RPC error codes\n\n## Authentication\n\nMCP Framework provides optional authentication for SSE endpoints. You can choose between JWT and API Key authentication, or implement your own custom authentication provider.\n\n### JWT Authentication\n\n```typescript\nimport { MCPServer, JWTAuthProvider } from \"mcp-framework\";\nimport { Algorithm } from \"jsonwebtoken\";\n\nconst server = new MCPServer({\n  transport: {\n    type: \"sse\",\n    options: {\n      auth: {\n        provider: new JWTAuthProvider({\n          secret: process.env.JWT_SECRET,\n          algorithms: [\"HS256\" as Algorithm], // Optional (default: [\"HS256\"])\n          headerName: \"Authorization\"         // Optional (default: \"Authorization\")\n        }),\n        endpoints: {\n          sse: true,      // Protect SSE endpoint (default: false)\n          messages: true  // Protect message endpoint (default: true)\n        }\n      }\n    }\n  }\n});\n```\n\nClients must include a valid JWT token in the Authorization header:\n```\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIs...\n```\n\n### API Key Authentication\n\n```typescript\nimport { MCPServer, APIKeyAuthProvider } from \"mcp-framework\";\n\nconst server = new MCPServer({\n  transport: {\n    type: \"sse\",\n    options: {\n      auth: {\n        provider: new APIKeyAuthProvider({\n          keys: [process.env.API_KEY],\n          headerName: \"X-API-Key\" // Optional (default: \"X-API-Key\")\n        })\n      }\n    }\n  }\n});\n```\n\nClients must include a valid API key in the X-API-Key header:\n```\nX-API-Key: your-api-key\n```\n\n### Custom Authentication\n\nYou can implement your own authentication provider by implementing the `AuthProvider` interface:\n\n```typescript\nimport { AuthProvider, AuthResult } from \"mcp-framework\";\nimport { IncomingMessage } from \"node:http\";\n\nclass CustomAuthProvider implements AuthProvider {\n  async authenticate(req: IncomingMessage): Promise<boolean | AuthResult> {\n    // Implement your custom authentication logic\n    return true;\n  }\n\n  getAuthError() {\n    return {\n      status: 401,\n      message: \"Authentication failed\"\n    };\n  }\n}\n```\n\n## License\n\nMIT\n"
}